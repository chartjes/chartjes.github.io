<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Grumpy Learning]]></title>
    <link href="https://grumpy-learning.com/blog/categories/testing.xml" rel="self"/>
    <link href="https://grumpy-learning.com/"/>
    <updated>2023-10-23T16:20:40+00:00</updated>
    <id>https://grumpy-learning.com/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Deciding How To Test Bug Fixes]]></title>
            <link href="https://grumpy-learning.com/blog/2023/05/03/deciding-how-to-test-bug-fixes/"/>
            <updated>2023-05-03T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/05/03/deciding-how-to-test-bug-fixes/</id>
            <content type="html"><![CDATA[<h1 id="deciding-how-to-test-bug-fixes">Deciding How To Test Bug Fixes</h1>

<p>"Hey Chris, I see that when Rusty went and updated his rotation for this
week, there are two entries. Looks like a bug."</p>

<p>For my <a href="https://www.ibl.org">other hobby</a> I also created a series of
old-school-spaghetti-and-lasagna-style PHP scripts for doing the
job of keeping track of rosters, player movement, and potential
pitching rotations. It was a mess. I was initially inspired by
Rasmus Lerdorf's <a href="https://toys.lerdorf.com/the-no-framework-php-mvc-framework">"The no-framework PHP MVC framework"</a>
blog post. I did a really bad implementation.</p>

<p>But that was okay, because only a few people used it and I
had extensive domain knowledge that made figuring out what
the expected behaviour was supposed to be.</p>

<p>While I was <a href="https://www.investopedia.com/terms/f/funemployment.asp">funemployed</a> during December 2022
I decided to go back and apply some structure to this application.
It became a <a href="https://www.slimframework.com">Slim</a> + <a href="https://www.doctrine-project.org">Doctrine</a>
application and I started working on refactoring it while also
making sure existing functionality behaved as expected.</p>

<p>It had very few tests and I did set about writing tests for the
refactored versions because who wants bugs? Except I forgot to
do some for some refactored functionality.</p>

<p>At a high level, here is the bug:</p>

<ul>
<li>a user is presented with a form to add free-form text to specific rows</li>
<li>when they click on the Save button, it is supposed to update details</li>
<li>it was instead adding new details, not updating</li>
</ul>

<p>No problem, I can fix this (and re-learn some things I had forgotten
about Doctrine) and will also test this.</p>

<h2 id="manual-vs.-automated">Manual vs. Automated</h2>

<p>As many people who have listened to me talk, in my opinion there is
a constant tension between "testing things manually" and "writing
an automated test". Sometimes this tension is because the people
involved are lazy. Sometimes it is due to time constraints. Sometimes
it's because the current system is difficult to test in an automated
way.</p>

<p>In this case I actually had two choices. I could work on code changes
and manually test them using the application itself. This is actually
how I normally do work on this particular application.</p>

<p>(As an aside, my normal policy is "if you pay me, I will automate
as much of the testing as I can". For hobby projects I literally
do whatever I feel like)</p>

<p>After looking at the refactored code, I realized that I would have
to make a bunch of changes so this was a great opportunity to create
an automated test that uses a real database.</p>

<p>This is very low-risk for this project as I am doing 99% of the
development work on this code base. There is no build server running
a series of checks. I need the real database to be there for me to
test out the "customer-facing" side of this application so no new
infrastructure is needed.</p>

<h2 id="real-tests">Real Tests</h2>

<p>This is the actual test I wrote and what the code looks like now.
I have been working on separating things out into Commands and Queries.
This was a Command I had to fix.</p>

<p>So, as always, I started off with a test. I still do Arrange-Act-Assert
as a way to organize the test. I thought about dependencies, like
a Request object and a Response object.</p>

<pre><code class="php">        $req = $this-&gt;createMock(Request::class);
        $req-&gt;expects($this-&gt;once())
            -&gt;method('getParsedBody')
            -&gt;willReturn([
                'week' =&gt; 99,
                'franchise_id' =&gt; [1],
                'rotation' =&gt; ['Moe, Larry, Curly'],
                'current_rotation' =&gt; [''],
                'rotation_id' =&gt; [0],
            ]
        );

        $response = $this-&gt;createMock(Response::class);
        $response-&gt;expects($this-&gt;any())-&gt;method('withStatus')-&gt;will($this-&gt;returnSelf());
        $response-&gt;expects($this-&gt;any())-&gt;method('withHeader')-&gt;will($this-&gt;returnSelf());
</code></pre>

<p>I also needed to make sure the database would work inside my test
environment. I just cut-and-paste code from a bootstrapping section
elsewhere in the application. Next time I write a test that needs
to use the database, I will extract this code into a helper.</p>

<pre><code class="php">        $container = new Container(require __DIR__ . '/../../config/settings.php');
        $container-&gt;set(EntityManager::class, static function (Container $c): EntityManager {
            $settings = $c-&gt;get('settings');

            $cache = $settings['doctrine']['dev_mode'] ?
                new ArrayAdapter() :
                new FilesystemAdapter(directory: $settings['doctrine']['cache_dir']);

            $config = ORMSetup::createAttributeMetadataConfiguration(
                $settings['doctrine']['metadata_dirs'],
                $settings['doctrine']['dev_mode'],
                null,
                $cache
            );

            return EntityManager::create($settings['doctrine']['connection'], $config);
        });

</code></pre>

<p>Because the application uses a dependency injection container, I also needed to
make sure my repository object I needed in the code would be available.</p>

<pre><code class="php">        $container-&gt;set(RotationRepository::class, function (Container $c): RotationRepository {
            return new RotationRepositoryUsingDoctrine($c-&gt;get(EntityManager::class));
        });


        /** @var RotationRepositoryUsingDoctrine $repo */
        $repo = $container-&gt;get(RotationRepository::class);
</code></pre>

<p>With those all set, the test becomes:</p>

<ul>
<li>Given I have an existing rotation</li>
<li>When I update that rotation</li>
<li>I should only see that updated rotation in the database</li>
</ul>

<pre><code class="php">        $command = new UpdateRotationsCommand($repo);
        $command-&gt;__invoke($req, $response);

        $rotation = $repo-&gt;getByWeekAndFranchiseId(99, 1);

        $req = $this-&gt;createMock(Request::class);
        $req-&gt;expects($this-&gt;once())
            -&gt;method('getParsedBody')
            -&gt;willReturn([
                'week' =&gt; 99,
                'franchise_id' =&gt; [1],
                'rotation' =&gt; ['Moe, Larry, Curly Joe'],
                'rotation_id' =&gt; [$rotation-&gt;getId()],
                'current_rotation' =&gt; ['Moe, Larry, Curly'],
            ]
        );
        $command = new UpdateRotationsCommand($container-&gt;get(RotationRepository::class));
        $command-&gt;__invoke($req, $response);

        $rotation = $repo-&gt;getByWeekAndFranchiseId(99, 1);

        $this-&gt;assertEquals('Moe, Larry, Curly Joe', $rotation-&gt;getRotation());
</code></pre>

<p>This test took me a bit of work to get exactly right, but I didn't go an write
any additional code just quite yet. I needed to:</p>

<ul>
<li>update the <code>UpdateRotationsCommand</code></li>
<li>add a new <code>getByWeekAndFranchiseId</code> method to my rotations repository object</li>
</ul>

<pre><code class="php">final class UpdateRotationsCommand
{
    public function __construct(private RotationRepository $repo) {}

    public function __invoke(Request $req, Response $response): Response 
    {
        $params = $req-&gt;getParsedBody();
        $week = (int) $params['week'];

        $franchiseIds = $params['franchise_id'];
        $rotations = $params['rotation'];
        $rotationIds = $params['rotation_id'] ?? [];
        $currentRotations = $params['current_rotation'];

        foreach ($franchiseIds as $idx =&gt; $franchiseId) {
            if ($rotations[$idx] !== $currentRotations[$idx]) {

                if (isset($rotationIds[$idx]) &amp;&amp; (int)$rotationIds[$idx] !== 0) {
                    $rotation = $this-&gt;repo-&gt;getById((int)$rotationIds[$idx]);
                    $rotation-&gt;setId((int)$rotationIds[$idx]);
                } else {
                    $rotation = new Rotation();
                }

                $rotation-&gt;setWeek($week);
                $rotation-&gt;setRotation($rotations[$idx]);
                $rotation-&gt;setFranchiseId((int) $franchiseId);
                $this-&gt;repo-&gt;save($rotation);
            }
        }

        return $response
            -&gt;withHeader('Location', '/rotation_management?week=' . $week)
            -&gt;withStatus(302);
    }
}
</code></pre>

<p>I remain convinced I can improve that code in the <code>foreach</code> but my goal is
always to make sure the bug no longer exists and then, if I want, go back
and make it "nicer".</p>

<pre><code class="php">    public function getByWeekAndFranchiseId(int $week, int $franchiseId): Rotation 
    {
        return $this-&gt;em
            -&gt;getRepository(Rotation::class)
            -&gt;findOneBy(['week' =&gt; $week, 'franchiseId' =&gt; $franchiseId]);
    }
</code></pre>

<p>So now I have an automated test that verifies that the bug was reported
no longer exists. Are there any new bugs lurking? No idea. Only three people
use this application so there are a whole series of tests I probably will
never have to write.</p>

<p>Here is the complete test:</p>

<pre><code class="php">declare(strict_types=1);

use Symfony\Component\Cache\Adapter\ArrayAdapter;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\ORMSetup;
use PHPUnit\Framework\TestCase;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Symfony\Component\Cache\Adapter\FilesystemAdapter;
use UMA\DIC\Container;
use Webreg\Command\UpdateRotationsCommand;
use Webreg\Repository\RotationRepository;
use Webreg\Repository\RotationRepositoryUsingDoctrine;

final class UpdateRotationsCommandTest extends TestCase
{
    /**
     * @test
     */
    public function itUpdatesExistingRecordsCorrectly(): void
    {
        $req = $this-&gt;createMock(Request::class);
        $req-&gt;expects($this-&gt;once())
            -&gt;method('getParsedBody')
            -&gt;willReturn([
                'week' =&gt; 99,
                'franchise_id' =&gt; [1],
                'rotation' =&gt; ['Moe, Larry, Curly'],
                'current_rotation' =&gt; [''],
                'rotation_id' =&gt; [0],
            ]
        );

        $response = $this-&gt;createMock(Response::class);
        $response-&gt;expects($this-&gt;any())-&gt;method('withStatus')-&gt;will($this-&gt;returnSelf());
        $response-&gt;expects($this-&gt;any())-&gt;method('withHeader')-&gt;will($this-&gt;returnSelf());

        $container = new Container(require __DIR__ . '/../../config/settings.php');
        $container-&gt;set(EntityManager::class, static function (Container $c): EntityManager {
            $settings = $c-&gt;get('settings');

            $cache = $settings['doctrine']['dev_mode'] ?
                new ArrayAdapter() :
                new FilesystemAdapter(directory: $settings['doctrine']['cache_dir']);

            $config = ORMSetup::createAttributeMetadataConfiguration(
                $settings['doctrine']['metadata_dirs'],
                $settings['doctrine']['dev_mode'],
                null,
                $cache
            );

            return EntityManager::create($settings['doctrine']['connection'], $config);
        });

        $container-&gt;set(RotationRepository::class, function (Container $c): RotationRepository {
            return new RotationRepositoryUsingDoctrine($c-&gt;get(EntityManager::class));
        });


        /** @var RotationRepositoryUsingDoctrine $repo */
        $repo = $container-&gt;get(RotationRepository::class);

        $command = new UpdateRotationsCommand($repo);
        $command-&gt;__invoke($req, $response);

        $rotation = $repo-&gt;getByWeekAndFranchiseId(99, 1);

        $req = $this-&gt;createMock(Request::class);
        $req-&gt;expects($this-&gt;once())
            -&gt;method('getParsedBody')
            -&gt;willReturn([
                'week' =&gt; 99,
                'franchise_id' =&gt; [1],
                'rotation' =&gt; ['Moe, Larry, Curly Joe'],
                'rotation_id' =&gt; [$rotation-&gt;getId()],
                'current_rotation' =&gt; ['Moe, Larry, Curly'],
            ]
        );
        $command = new UpdateRotationsCommand($container-&gt;get(RotationRepository::class));
        $command-&gt;__invoke($req, $response);

        $rotation = $repo-&gt;getByWeekAndFranchiseId(99, 1);

        $this-&gt;assertEquals('Moe, Larry, Curly Joe', $rotation-&gt;getRotation());
    }
}
</code></pre>

<p>So now I know that manually testing things is the last option to verify
behaviour, not my only option.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[NeoVim and Xdebug]]></title>
            <link href="https://grumpy-learning.com/blog/2023/04/03/neovim-and-xdebug/"/>
            <updated>2023-04-03T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/04/03/neovim-and-xdebug/</id>
            <content type="html"><![CDATA[<h1 id="neovim-and-xdebug">NeoVim and Xdebug</h1>

<p>As I continue to work on the configuration for the <a href="https://neovim.io">One True Editor</a>
I had everything working just about the way that duplicated how I use <a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a>
except for one thing -- using <a href="https://xdebug.org">Xdebug</a>.</p>

<p>As I write this blog post I have an article submitted for <a href="https://www.phparch.com">php[architect]</a>
on how I use NeoVim to do PHP development work and in that article
I talked about the next few things I was going to work on adding
support for ($100 a year to do enemy research on Copilot AI?!?)
and getting the tool that I regret not embracing earlier but
now find it indispensable.</p>

<p>This is not the blog post if you are looking to figure out
how to get Xdebug running with whatever version of PHP you
are trying to use. The excellent documentation on the Xdebug
web site will absolutely point you in the right direction.</p>

<p>In my case, I went the route of manually compiling the 3.2.x
series (I honestly cannot remember why) but most package
managers for your operating system of choice can help you
with that.</p>

<h2 id="xdebug-and-dap">Xdebug and DAP</h2>

<p>DAP (which is short for the <a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Anywhere Protocol</a>.
Look, you can quibble about who is behind DAP but the overarching
goal of providing a standardized way for both debugging tools
and programming languages to talk to each other makes a lot
of sense. The <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>
is a similar effort that has found a lot of traction outside
of Microsoft.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>You to have the following before we get started:</p>

<ul>
<li>a version of PHP with Xdebug support</li>
<li>NeoVim 0.5+ or better</li>
<li>the ability to edit your NeoVim configuration files</li>
<li>the ability to install NeoVim plugins</li>
<li>Node installed (need it to install some tooling)</li>
<li>Git CLI tools installed</li>
</ul>

<h2 id="debug-adapter-for-php">Debug Adapter for PHP</h2>

<p>To start, I followed the excellent instructions found <a href="https://github.com/mfussenegger/nvim-dap/wiki/Debug-Adapter-installation#PHP">here</a>
but to replicate them here:</p>

<pre><code class="bash">git clone https://github.com/xdebug/vscode-php-debug.git
cd vscode-php-debug
npm install &amp;&amp; npm run build
</code></pre>

<p>Leveraging an existing tool to make it work is always galaxy-brain-level
thinking.</p>

<p>Next, I decided on which plugins I wanted to use to interact
with Xdebug while inside NeoVim. I chose:</p>

<ul>
<li><a href="https://github.com/mfussenegger/nvim-dap">mfussenegger/nvim-dap</a> for high-level support</li>
<li><a href="https://github.com/rcarriga/nvim-dap-ui">rcarriga/nvim-dap-ui</a> as my UI for looking at the debug details</li>
<li><a href="https://github.com/theHamsta/nvim-dap-virtual-text">theHamsta/nvim-dap-virtual-text</a> find variable definitions</li>
<li><a href="https://github.com/nvim-telescope/telescope-dap.nvim">nvim-telescope/telescope-dap.nvim</a> to provide compatibility with Telescope</li>
</ul>

<p>Again, I encourage people to start with a base that WORKS and
then start experimenting to get it the way you want it.</p>

<h2 id="dap-plugin-configuration">DAP Plugin Configuration</h2>

<p>Again, this is for my own setup. It might be different for your
own.</p>

<p>I needed to make sure that I turn on Telescope support in my
<code>init.vim</code> file. I need it for other plugins but make sure
you enable it if you are using <code>telescope-dap.nvim</code>.</p>

<pre><code class="bash">lua require('telescope').setup
</code></pre>

<p>Note that the above is how to load <a href="https://www.lua.org">Lua</a> files
inside a <a href="https://devhints.io/vimscript">Vimscript</a> file. I am starting
to work on the outline of using Lua for all my NeoVim configuration
settings.</p>

<p>Next, I have a configuration file just for DAP that I also load in
my <code>init.vim</code> file:</p>

<pre><code class="lua">local dap = require('dap')
require('telescope').load_extension('dap')

dap.adapters.php = {
    type = "executable",
    command = "node",
    args = { os.getenv("HOME") .. "/vscode-php-debug/out/phpDebug.js" }
}

dap.configurations.php = {
    {
        type = "php",
        request = "launch",
        name = "Listen for Xdebug",
        port = 9003
    }
}
</code></pre>

<p>In here I tell NeoVim:</p>

<ul>
<li>load the DAP extension for Telescope (it overrides the default UI)</li>
<li>I want to use the VS Code DAP adapter</li>
<li>what port to listen for Xdebug info on (Xdebug 3.2.x goes with 9003 as the standard port)</li>
</ul>

<p>On the Xdebug web site section <a href="https://github.com/xdebug/vscode-php-debug#supported-launchjson-settings">about VS Code</a>
it points out that you can also add in a <code>pathMappings</code>
value in <code>dap.configurations.php</code> to "map the files on the server to
the right files on your local machine." and gives an example.</p>

<p>I don't use <code>pathMappings</code> and my setup works just fine.</p>

<p>Of course, I could not really use Xdebug from inside the editor without
some keyboard mappings:</p>

<pre><code class="lua">vim.keymap.set('n', '&lt;F5&gt;', function() require('dap').continue() end)
vim.keymap.set('n', '&lt;F10&gt;', function() require('dap').step_over() end)
vim.keymap.set('n', '&lt;F11&gt;', function() require('dap').step_into() end)
vim.keymap.set('n', '&lt;F12&gt;', function() require('dap').step_out() end)
vim.keymap.set('n', '&lt;Leader&gt;b', function() require('dap').toggle_breakpoint() end)
vim.keymap.set('n', '&lt;Leader&gt;B', function() require('dap').set_breakpoint() end)
vim.keymap.set('n', '&lt;Leader&gt;lp', function() require('dap').set_breakpoint(nil, nil, vim.fn.input('Log point message: ')) end)
vim.keymap.set('n', '&lt;Leader&gt;dr', function() require('dap').repl.open() end)
vim.keymap.set('n', '&lt;Leader&gt;dl', function() require('dap').run_last() end)
vim.keymap.set({'n', 'v'}, '&lt;Leader&gt;dh', function()
  require('dap.ui.widgets').hover()
end)
vim.keymap.set({'n', 'v'}, '&lt;Leader&gt;dp', function()
  require('dap.ui.widgets').preview()
end)
vim.keymap.set('n', '&lt;Leader&gt;df', function()
  local widgets = require('dap.ui.widgets')
  widgets.centered_float(widgets.frames)
end)
vim.keymap.set('n', '&lt;Leader&gt;ds', function()
  local widgets = require('dap.ui.widgets')
  widgets.centered_float(widgets.scopes)
end)
</code></pre>

<p>My usual workflow for debugging is:</p>

<ul>
<li>code I am debugging open in the editor</li>
<li>if I didn't already start debugging, hit <code>F5</code> to turn on the debugging session</li>
<li>set breakpoints where I want them with <code>\b</code></li>
<li>run the code, step through the breakpoints, and see what's going on</li>
</ul>

<p>Not different in any significant way than how I would do things in PhpStorm.</p>

<p>So there you have it! If you are a NeoVim user and want to
start utilizing Xdebug to help you, well, debug your code
faster my documentation above should get you pointed in
the correct direction.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Thinking About Testing Too Much]]></title>
            <link href="https://grumpy-learning.com/blog/2023/03/09/thinking-about-it-too-much/"/>
            <updated>2023-03-09T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/03/09/thinking-about-it-too-much/</id>
            <content type="html"><![CDATA[<h1 id="thinking-about-testing-too-much">Thinking About Testing Too Much</h1>

<p>Back in February and had a <a href="https://www.freethegeek.fm/51">very long and fun chat</a> with
my friend Matt Setter about the one topic I think about way too much -- testing. Rather
than steal what Matt wrote, just go read the linked above post to get a sense of what
we discussed. If you have followed my rantings online for any period of time, none of
what I discussed there should be new to you.</p>

<p>I mean, you can't really blame me -- my career niche has been "testing PHP code" since at
least 2006. That is a really, really long time to be focussed on an issue. Now, I might
not be the best programmer (a lot of times I feel like I have been doing programming for
1 year, 25 times) but I do know a ton about what does and does not lead to good outcomes
for long-running projects.</p>

<h2 id="the-next-wave-of-testing">The Next Wave Of Testing</h2>

<p>As I write this, I am at a crossroads as to what to talk about next. I'm kind of over speaking
at conferences except in places I have not been (if you are an organizer of an event in Africa,
South America, or Japan -- please get in touch) and I am not sure I want to put the effort
in to write yet another book or do training courses. If I am being honest, I am getting older
and like hanging out at home more and having unstructured time. I have two frustrating hobbies
that can keep my mind sharp. Arguing with people about testing their code feels like a losing
proposition and a huge waste of my time.</p>

<p>So, what I have found interesting is the increasingly-growing idea that there are some code-related
things that you can do that can reduce the amount of tests you need to write for your code
or sometimes even eliminate them. This is, of course, at best misguided and at worst, wrong.</p>

<h2 id="types-as-tests">Types As Tests</h2>

<p>When they got introduced into the language, I viewed typing (I define it as declaring at creation
what 'type' of thing an object or variable is supposed to be) as something that would get rid
of some types of tests I found myself writing and allow the PHP interpreter to enforce rules
about what sort of things my code was returning to other code that called it. No more tests
verifying that a method returned an array!</p>

<p>They are NOT a substitute for tests. They are a helpful tool that provides intent for your code
and greatly reduces the likelihood of SOME types of errors happening when (for example) your
code is expecting a list of things and instead gets a string.</p>

<h2 id="static-analysis-as-tests">Static Analysis As Tests</h2>

<p>Static analysis tools are something I have been using professionally for a few years. They are
an additional layer ON TOP OF types that goes even further down the road of making sure the intent
of your code is clear. Sure, it's annoying to have a tool say "well, actually, you said over HERE
that you are expecting an array but you ACTUALLY are passing a list. What one is it?" but it's
better than you trying to figure out why some code you wrote yesterday suddenly stopped working
today when you (and this is often not reality) "didn't change anything".</p>

<p>Again, these are NOT a substitute for tests. They are a COMPLEMENTARY tool for testing. Just because
PHPStan is not reporting any errors doesn't mean your code is behaving as expected!</p>

<h2 id="grumpy%27s-theory-on-tests">Grumpy's Theory On Tests</h2>

<p>I am incredibly confident in saying that you should 100% have automated tests for your application
that cover:</p>

<ul>
<li>business logic</li>
<li>how your users will interact with your app</li>
</ul>

<p>What testing tools you use to make this happens is up to you. If you have done a decent job of
creating a decoupled code base where you are injecting dependencies to your objects (let's be
real, 90% of PHP code out there still running and accessible online is object oriented) then
you should be able to write unit tests where you create the dependencies the code you are testing
needs.</p>

<p>They can be the real thing (which I prefer) or doubles (don't be scared, you probably waste more
time on social media than it would take to keep the doubles in sync as you work on the code base)
but you MUST have the ability to modify these dependencies at run time.</p>

<p>If you also write your code in a more defensive style -- think filtering input, escaping output,
validating things, using immutability -- your tests become easier
to create and the testing scenarios you create become easier and easier to define and implement.</p>

<p>You need tests. Your code should be easy to test. I'm not mad at you if your code isn't in a place
where it easy to test. There are ways  to make them testable. No, I am
not talking about end-to-end tests with browser automation. Those are brittle and I have seen too
many of those types of test suites with weird custom helpers and step definitions that do not
reflect how the application works AT ALL. Don't do that. Browser automation is a last, desperate
test in my opinion.</p>

<p>Write assertion-based tests using real dependencies as much as possible. I'm happy to help you
get there. It will cost some time and some money but it will make the cost of the NEXT change so
much easier.</p>

<p>Hope you enjoyed the results of thinking too much about this stuff. There is SO much more I want
to learn in order to make your testing tasks easier.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Monkey patching in PHP]]></title>
            <link href="https://grumpy-learning.com/blog/2023/01/19/monkeypatching-in-php/"/>
            <updated>2023-01-19T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/01/19/monkeypatching-in-php/</id>
            <content type="html"><![CDATA[<h2 id="what-is-monkey-patching%3F">What is monkey patching?</h2>

<p>I first learned about <a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a> via the Ruby community. Due to how
the language worked, Rubyists tended to override dependencies in their
tests at run-time, rather than using <a href="https://en.wikipedia.org/wiki/Test_double">test doubles</a>.
Personally I find the ability to redefine <em>any</em> part of the language to be interesting. It 
certainly does make testing easier.</p>

<p>Now, PHP doesn't support the sort of <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> that lends
itself to making monkey patching easy. Sure, you used to be able to use the Runkit extension but
these days, it's not being maintained. So, when we run into a situation where you need to redefine
some functionality at run time, your options are limited.</p>

<h2 id="when-to-use-it%3F">When to use it?</h2>

<p>Like I said before, it can be an alternative to using test doubles. But there are also some
interesting scenarios where, due to both PHP's behaviour and the architecture of an application,
we can make a change at run time.</p>

<p>At my <a href="https://smartours.com">current gig</a> I was adding some functionality
to verify some objects representing the prices of objects are configured
correctly. One of my tests was to ensure that a specific exception was
being triggered, and that meant creating a new exception object that
extended a "loggable" one.</p>

<p>This is code that is being implemented as a <a href="https://wordpress.org/plugins/">plugin</a>
for WordPress and the logging object I needed to use had some very
WordPress-specific functionality in it. But I didn't want to have to use all
the WordPress-specific stack just for this test. On top of this, the logging
object wasn't in a namespace that my <a href="https://phpunit.de">PHPUnit</a> tests could
even see.</p>

<p>So what were my options? My first was to modify the <a href="https://getcomposer.org">Composer</a>
autoloading configuration and add the namespace to it. I then had a way to
"force" logging into "test mode" but I wasn't entirely happy with it. The
tests passed, the exception was being triggered, but I had worries in the back
of my mind about whether or not we'd have to do something to the WordPress
side of the application in order to support this.</p>

<p>A <a href="https://phpc.social/@omerida">co-worker</a> showed me how they were already overriding some things at run-time,
so it was better to go with what was already working. Introducing uncertainty
into our application was not the end goal. Here was their solution:</p>

<p>There was an existing <code>test/bootstrap.php</code> file so it was suggested to add a run-time
check to see if the application was attempting to instantiate our logging
object via an autoloader and then instead tell it to use a different one.</p>

<p>First, a replacement logger was created...</p>

<pre><code class="php">&lt;?php

namespace Smartours\Log;

use Monolog\Handler\NullHandler;
use Monolog\Logger;

class Log
{
    public static function logger(): Logger
    {
        $logger = new Logger('generic');
        $logger-&gt;pushHandler(new NullHandler());

        return $logger;
    }
}

</code></pre>

<p>...and then we just included it in our bootstrap file.</p>

<pre><code>require __DIR__ . '/bootstrap/SmartoursLog.php';
</code></pre>

<p>Now, my code that is calling an exception...that needs that
base <code>Log</code> object...will use my <a href="https://en.m.wikipedia.org/wiki/Mock_object">fake</a>
instead.</p>

<p>The test passes and all is in order again.</p>

<h2 id="what-are-some-alternatives%3F">What are some alternatives?</h2>

<p>In a more testable world, what logging object the code is
expecting to use could be done via a configuration file. We'd
still be creating a fake logger, but the mechanism to load it
would be different. Most "modern" PHP web application frameworks
support the use of <a href="https://en.m.wikipedia.org/wiki/Service_locator_pattern">service locaters</a>
and they can be leveraged to make sure your tests have access
to the dependencies they need.</p>

<p>In the future, if we ever needed to add tests for things like making
sure the message the exception we throw shows up in the correct log
file, this solution will have to adapt to those needs.</p>

<p>As always, everyone's testing situation is different and finding
one that fits your need is more important than being perfect..</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Testing decoupled PHP code?]]></title>
            <link href="https://grumpy-learning.com/blog/2022/12/06/testing-decoupled-code/"/>
            <updated>2022-12-06T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/12/06/testing-decoupled-code/</id>
            <content type="html"><![CDATA[<p>One of the reasons many experienced developers encourage the concept of
"decoupling your code" is so that it makes testing your code straightforward.
I wanted to share an example of how I went about writing some tests for
some code that I had refactored from being a tangled spaghetti-like mess.</p>

<p>Here is the code I am looking at, written targeting PHP 8.1.</p>

<pre><code class="php">&lt;?php
declare(strict_types=1);

namespace Webreg\Query;

use Slim\Psr7\Response;
use Slim\Psr7\Request;
use Twig\Environment;
use Webreg\Repository\GameRepository;
use Webreg\ViewModel\Rotations;

final class RotationManagementQuery
{
    public function __construct(
        private Environment $twig,
        private GameRepository $gameRepository,
        private Rotations $rotations
    ) {}

    public function __invoke(Request $request): Response
    {
        $params = $request-&gt;getQueryParams();
        $maxWeek = $this-&gt;gameRepository-&gt;getMaxWeek();
        $week = (isset($params['week'])) ? (int) $params['week'] : $maxWeek;
        $rotations = $this-&gt;rotations-&gt;getAllByWeek($week);
        $response = new Response(200, null);
        $response-&gt;getBody()-&gt;write($this-&gt;twig-&gt;render('rotations/management.twig', [
            'current_week' =&gt; $week,
            'rotations' =&gt; $rotations,
        ]));

        return $response;
    }
}
</code></pre>

<p>I am using <a href="https://www.martinfowler.com/bliki/CQRS.html">Command Query Responsibility Segregation</a> in
this application's architecture, and this bit of code is a Query that will
retrieve a collection of pitchers who will be starting for baseball
teams in my simulation baseball league for a particular week.</p>

<p>In following some rules for decoupling, you can see some of the
following decisions had been made:</p>

<ul>
<li>not extending off of a base class</li>
<li>all dependencies are injected at run time</li>
<li>single-method for the class</li>
</ul>

<h2 id="identifying-dependencies">Identifying Dependencies</h2>

<p>So what are the dependencies I will need?</p>

<ul>
<li>a <a href="https://twig.symfony.com">Twig</a> object</li>
<li>a <a href="https://martinfowler.com/eaaCatalog/repository.html">repository</a> object for retrieving data</li>
<li>a <a href="https://martinfowler.com/eaaDev/PresentationModel.html">view model</a> for presenting the data</li>
<li>an object that contains the HTTP <a href="https://www.php-fig.org/psr/psr-7/">request</a></li>
</ul>

<p>In the old architecture, I was creating those dependencies deep inside the "business logic"
and therefore it was very hard to write anything other than some kind of "check
the HTML output" type of test. Ironically that is what the new test does as well but
this sort of decoupled architecture leads to a much more straightforward test.</p>

<h2 id="identifying-output">Identifying Output</h2>

<p>In these tests, I wanted to make sure that if I had at least one rotation
stored in the database for a particular week, when the page renders I should
see that rotation in the output somewhere.</p>

<h2 id="test-skeleton">Test Skeleton</h2>

<p>As always, I break out the <a href="http://wiki.c2.com/?ArrangeActAssert">Arrange-Act-Assert</a> pattern
to create the skeleton of the test:</p>

<pre><code class="php">    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange

        // Act

        // Assert
        self::fail();
    }
</code></pre>

<p>Remember, you always want to start with a failing test.</p>

<h2 id="arranging-our-dependencies">Arranging our dependencies</h2>

<p>These days I try and use the fewest number of <a href="https://phpunit.readthedocs.io/en/9.5/test-doubles.html">test doubles</a>
in my test scenarios. Given the dependencies I needed,
I was going to need three "fake" dependencies, configured
to provide only the implementation details required to make
the scenario work.</p>

<p>I don't want to get into a longer discussion on the use of
test doubles except to say that the decoupling strategy
I am using will minimize the chances that any doubles drift
from how the code is actually implemented.</p>

<p>Trust me, I do this for a living!</p>

<pre><code class="php">    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange
        $loader = new FilesystemLoader(__DIR__ . '/../../templates/');
        $twig = new Environment($loader);

        $gamesRepo = $this-&gt;createMock(GameRepository::class);
        $gamesRepo-&gt;expects($this-&gt;once())
            -&gt;method('getMaxWeek')
            -&gt;willReturn(1);

        $testRotation = new ArrayCollection();
        $testRotation-&gt;add([
            'franchise_id' =&gt; 1,
            'ibl' =&gt; 'MAD',
            'rotation' =&gt; 'One, Two, Three'
        ]);

        $viewModel = $this-&gt;createMock(RotationsUsingDoctrine::class);
        $viewModel-&gt;expects($this-&gt;once())
            -&gt;method('getAllByWeek')
            -&gt;willReturn($testRotation);

        $request = $this-&gt;createMock(Request::class);
        $request-&gt;expects($this-&gt;once())
            -&gt;method('getQueryParams')
            -&gt;willReturn(['week' =&gt; 1]);

        // Act

        // Assert
        self::fail();
    }
</code></pre>

<h2 id="acting-on-the-code-under-test">Acting on the code-under-test</h2>

<p>This has always struck me as a weird way to describe "executing the
code we are testing" but I guess "Arrange-Execute-Assert" doesn't
flow in English quite the same way.</p>

<p>Now that I have all my dependencies created and configured the way
I need, time to run the code and grab some results I can test.</p>

<pre><code class="php">    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange

        // Act
        $query = new RotationManagementQuery($twig, $gamesRepo, $viewModel);
        $results = $query-&gt;__invoke($request);

        // Assert
        self::fail();
    }
</code></pre>

<h2 id="asserting-results-of-code-execution">Asserting results of code execution</h2>

<p>Just like I did before, I am checking the HTML output from executing
this Query to make sure I am seeing values that I expect</p>

<pre><code class="php">    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange

        // Act

        // Assert
        self::assertStringContainsString('One, Two, Three', $results-&gt;getBody());
    }
</code></pre>

<p>When building my assertions, I tend to go with "what are the
fewest number of things I need to do in order to prove the
code is working as expected."</p>

<p>In this case, I felt checking that I see an expected "pitching rotation"
in the output is good enough.</p>

<p>Here is what the whole test looks like:</p>

<pre><code class="php">&lt;?php

namespace Webreg\Test\Query;

use Doctrine\Common\Collections\ArrayCollection;
use Slim\Psr7\Request;
use Twig\Environment;
use Twig\Loader\FilesystemLoader;
use Webreg\Query\RotationManagementQuery;
use PHPUnit\Framework\TestCase;
use Webreg\Repository\GameRepository;
use Webreg\ViewModel\RotationsUsingDoctrine;

class RotationManagementQueryTest extends TestCase
{
    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange
        $loader = new FilesystemLoader(__DIR__ . '/../../templates/');
        $twig = new Environment($loader);

        $gamesRepo = $this-&gt;createMock(GameRepository::class);
        $gamesRepo-&gt;expects($this-&gt;once())
            -&gt;method('getMaxWeek')
            -&gt;willReturn(1);

        $testRotation = new ArrayCollection();
        $testRotation-&gt;add([
            'franchise_id' =&gt; 1,
            'ibl' =&gt; 'MAD',
            'rotation' =&gt; 'One, Two, Three'
        ]);

        $viewModel = $this-&gt;createMock(RotationsUsingDoctrine::class);
        $viewModel-&gt;expects($this-&gt;once())
            -&gt;method('getAllByWeek')
            -&gt;willReturn($testRotation);

        $request = $this-&gt;createMock(Request::class);
        $request-&gt;expects($this-&gt;once())
            -&gt;method('getQueryParams')
            -&gt;willReturn(['week' =&gt; 1]);

        // Act
        $query = new RotationManagementQuery($twig, $gamesRepo, $viewModel);
        $results = $query-&gt;__invoke($request);

        // Assert
        self::assertStringContainsString('One, Two, Three', $results-&gt;getBody());
    }
}

</code></pre>

<p>Some thoughts that occur to me from looking at the final test:</p>

<ul>
<li>decoupling makes your dependencies quite visible during test creation</li>
<li>always make sure to only implement the behaviour of your test doubles that you need</li>
<li>your Arrange step will almost always be the largest part of any test</li>
<li>PHPUnit's built-in test double generators also act as assertions</li>
<li>sometimes the simplest way of verifying behaviour is what you should use</li>
</ul>

<p>From my perspective, decoupling the code allows me to focus on smaller
pieces of application behaviour, reducing the chances that a change in
this code breaks something somewhere else.</p>

<p>For more details on the approach I am using for decoupling my code, check
out Matthias Noback's <a href="https://leanpub.com/recipes-for-decoupling">"Recipes for Decoupling"</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Why isn&#039;t testing ubiquitous?]]></title>
            <link href="https://grumpy-learning.com/blog/2022/11/22/why-isnt-testing-ubiquitous/"/>
            <updated>2022-11-22T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/11/22/why-isnt-testing-ubiquitous/</id>
            <content type="html"><![CDATA[<p>Over on Twitter Mathias Verraes tweeted something that immediately 
triggered some feelings:</p>

<blockquote>
  <blockquote>
    <p>Perhaps TDD isn't as ubiquitous as it should be because you
    can't make a business model out of it.
    (Original post on Twitter <a href="https://twitter.com/mathiasverraes/status/1595100145129263106">https://twitter.com/mathiasverraes/status/1595100145129263106</a></p>
  </blockquote>
</blockquote>

<p>I commented saying "Boy do I ever have feelings about this topic..." and
Matias asked me to share. I decided my response was better off as
a longer blog post. Don't worry, this will end up on Twitter / Mastodon
anyway.</p>

<p>He mentioned "observability" as a technique that ended up
being a very good business model. Why? In my opinion, figuring out
how to observe something in production is generic enough in that you
can create a tool and say "hey, add these stuff to your code or
production systems, and it will report stuff to this well-crafted
dashboard you can use to get an idea of what is going on."</p>

<p>I am a fan of these approach -- I highly recommend looking into
things like <a href="https://www.honeycomb.io">Honeycomb</a> to get an idea
of what you are signing up for when you choose that path.</p>

<p>So what about testing? Is testing generic enough that you could come
up with some kind of black box or external system that you can connect
your tests to and react to when things fail?</p>

<p>Tests are almost entirely bespoke. Dependent on architecture. Dependent
on environments. Heck, dependant on the skill of the people who have to
write and maintain them.</p>

<p>Also, in my experience, tests work best when you approach them from
the idea that they are there to make sure things are behaving as you
expect them to and to give you a way to determine if you've made changes
that have broken something elsewhere in your application.</p>

<p>In other words, chances are that a failing test is something that the
users of your application will never notice. They will notice broken
pages, non-functioning links, slow-to-respond interfaces. Those are things
that can probably be monitored through observability tools.</p>

<p>In a lot of cases you start off with the idea of having to add tests to
a system being adversarial. Developers don't want to spend the time
writing them. Management views them as tasks with little-to-no return
on investments. Clients balk at being told your bid is more expensive because
you are writing tests. Flaky tests reduce confidence. Build tools need
to be able to play nicely with your chosen testing tools. Effective
test suites can take a lot of time to create and maintain.</p>

<p>Not to mention almost nobody teaches people how to learn to use a programming
language from a test-centric perspective. I could not even imagine
how to teach a novice programmer how to use PHP while also showing them
how to use all the tools. Understanding my own target audience is developers-with-experience
has really changed how I teach and what I teach them.</p>

<p>Using an observability tool
can often be as simple as signing up for an online tool, follow their
directions on what needs to happen to monitor things, and then you
will know a lot faster when things aren't behaving correctly in
production.</p>

<p>Under those types of terms, testing will never be ubiquitous. Which
is a shame because it is a technique that can lead to stable code
bases and confident deployments to production.</p>

<p>Maybe someone out there with a different perspective will figure out
how to solve the stuff I talked about here. Until then, I am still happy
to help teach people how to add automated testing to their skill set
and hope they find it as useful as I have.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Asking Companies About Testing]]></title>
            <link href="https://grumpy-learning.com/blog/2022/01/14/asking-companies-about-testing/"/>
            <updated>2022-01-14T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/01/14/asking-companies-about-testing/</id>
            <content type="html"><![CDATA[<p>This post could also be subtitled "The Grumpy Programmer's Guide to Getting Rejected at Interviews".</p>

<p>Someone tagged me in a tweet...</p>

<blockquote>
  <p><em>Book idea for @grmpyprogrammer: an interviewing guide for job seekers wanting to get an idea of how dedicated companies are to testing. Questions to ask, ways to gauge the culture, etc.</em>
  <em>(Originally posted on Twitter at <a href="https://twitter.com/n00bJackleCity/status/1481632465403981824?s=20">https://twitter.com/n00bJackleCity/status/1481632465403981824?s=20</a>)</em></p>
</blockquote>

<p>...and it got me to thinking about where to start with
a request like this one. My personal opinion that there
really isn't a book in here but it did get me to start thinking
about what sort of questions you should be asking.</p>

<p>Again, keep in mind that all of this is just my opinion. One based
on many years of experience, but still an opinion.</p>

<h2 id="why-does-it-matter%3F">Why Does It Matter?</h2>

<p>In my experience, companies that make a commitment to doing automated
testing also tend to make a commitment towards "quality"
in their coding practices and "automation" in their software development tooling.
The reason those are in quotes is because they definitely can mean 
different things depending on the company.</p>

<p>Now, again, in my experience, you are likely to have more success
in solving problems and growing your own skills as a developer if you work
in an environment where they value those things.</p>

<p>After all, just because we can get paid a lot of money to dig in the pixel
mines doesn't mean we should be forced to eat a shit sandwich. We should at 
least have a choice of the additional toppings.</p>

<h2 id="what-questions-should-i-ask%3F">What Questions Should I Ask?</h2>

<p>Like a lot of things related to programming, I find it helpful to start at the
end result you want and work backwards to figure out what needs to be done. Therefore
I think the first two things to ask are:</p>

<blockquote>
  <blockquote>
    <p>What things always have to work when you push changes into production
    and how do you verify that it works as expected?</p>
  </blockquote>
</blockquote>

<p>This question cuts to the heart of the issue: what matters and how do we make
sure it stays that way.</p>

<p>What you are looking for is clear statements about what matters and clearer statements
about how they verify it. Again, not every company has invested the time and money
into having the ability for code changes to seamlessly flow from a development
environment into production, accompanied by effective automated tests and a clear understanding
of outcomes.</p>

<p>If they already have some kind of commitment to testing, asking follow-up questions
like this are also very informative:</p>

<blockquote>
  <blockquote>
    <p>What do you like about your current testing practices and what do you want to change?</p>
  </blockquote>
</blockquote>

<p>Pay as much attention to what they like as what they dislike. That will give you an idea
of what challenges lie ahead if you want to be the person making the changes.</p>

<p>Finally, if you want to find out about what their commitment to quality is, I feel like
a great question is:</p>

<blockquote>
  <blockquote>
    <p>Tell me about how code gets from the developer and up into production</p>
  </blockquote>
</blockquote>

<p>Look for things like:</p>

<ul>
<li>code reviews</li>
<li>coding standards</li>
<li>static code analysis</li>
<li>continuous integration systems</li>
<li>separate staging and production environments</li>
<li>automated deployments</li>
</ul>

<p>Not all of these things are going to guarantee great results (nothing
does and never believe anyone who says it) but, when taken together,
they show a commitment to making sure that:</p>

<ul>
<li>the intent of code is clear</li>
<li>others can understand the code</li>
<li>the code is taking advantage of appropriate language features</li>
<li>the team uses tooling that integrates with version control to automate error-prone manual checklists</li>
<li>application / end-to-end testing happens before it reaches production</li>
<li>repeatable processes ensure consistency</li>
</ul>

<h2 id="so-now-what%3F">So Now What?</h2>

<p>It's hard for me to give any more specific advice other than "don't be 
afraid to ask more questions based on the answers you are hearing." 
If we're being honest, most companies aren't doing all that stuff I listed
above. You can always start at the bottom ("we try and manually test all changes")
and work as hard as you are allowed to on getting to the point where you
have an automated test suite catching issues before your users do.</p>
]]></content>
        </entry>
    </feed>