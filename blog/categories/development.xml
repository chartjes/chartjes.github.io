<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Grumpy Learning]]></title>
    <link href="https://grumpy-learning.com/blog/categories/development.xml" rel="self"/>
    <link href="https://grumpy-learning.com/"/>
    <updated>2024-03-10T15:51:03+00:00</updated>
    <id>https://grumpy-learning.com/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[When giving talks gets boring]]></title>
            <link href="https://grumpy-learning.com/blog/2024/03/10/when-giving-talks-gets-boring/"/>
            <updated>2024-03-10T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/03/10/when-giving-talks-gets-boring/</id>
            <content type="html"><![CDATA[<p>Over on federated social media, my long-time programming
friend (and former JavaScript developer meetup organizer)
<a href="https://hachyderm.io/@dcousineau">Daniel Cousineau</a> had 
a multi-post thread lamenting the demise of the "tech meetup"
and was wondering what to do about it?</p>

<p>Daniel's thoughts on this caused me to reflect on my years
of doing developer advocacy via speaking at conferences and
meetups. I've been doing it since 2016 and, well, I know this
sounds weird but I got bored and decided to do it a lot less.</p>

<p>Just before we occupied the current Fortress of Grumpitude back
in 2017, I had been basically going full-throttle with career-related
travl. When February 2018 rolled around, I had just finished
a streak of getting on a plane for work or to speak at an event
for 36 straight months. The evil Facebook reminded me that in 
2016 I spoke in Autralia, Serbia, England, and Chicago all before
the end of July. Not to mention travelling at least twice a year
for Mozilla events.</p>

<p>I was tired and wanted a change. I had also grown weary of talking
about testing. Sure, it was my thing. But there were so many other
things I was interested in talking about and sharing. So by
conference attendance dropped to doing one talk a year basically.
Then the pandemic started and there were a few random online
events I participated in.</p>

<p>Still didn't feel very satisfied. Still was super bored.</p>

<p>Then I made the decision when I attended Longhorn PHP 2022 that
I was not going to do any testing talks any more. I did a three
hour talk that attempted to summarize everything I had gone
through on my journey to becoming on of the most vocal and (for a
time) well-known PHP testing evangelists.</p>

<p>Then I went to php|tek in Chicago in 2023 not as an attendee, but
to volunteer at the booth for <a href="https://osmihelp.org">OSMI</a> -- Open
Sourcing Mental Illness. My good friend Ed Finkler started up
this non-profit and it continues to do unappreciated work in
the programming community. It was close enough that I could drive.
Flying would've been about 6.5 hours door-to-door -- the drive
in my MuskMobile was about 8.5 hours with stops for meals and
charging. A lot cheaper than flying though. The weather was great,
the miles slowly piled up, and I got to hang out with a lot of
my friends for the first time in a long time.</p>

<p>It was great to sit in a booth and not feel any pressure to deliver
talks. Not that I had felt pressure in a long time, but it is still
a non-trivial amount of work to come up with a talk. Deciding on
material, creating slides, practicing the talk (although after
many years of public speaking I can often improvise).</p>

<p>I still have the desire to share, to advocate for things I find
interesting. So I decided if I was going to do talks again on
my once-a-year schedule, they were going to be on my terms.</p>

<p>Luckily, I can still write talk proposals that get accepted. I
will once again be speaking at php|tek 2024. I will be driving
there again in the MuskMobile, but a long-time friend who has
never been to Chicago is going to come with me and we'll do
some touristy stuff and then he can wander off to do his own
thing while I speak.</p>

<p>So, what did I decide to do to keep things from being boring?
By making my talks stealth talks.</p>

<p>I'm giving two talks -- one about Command-Query Responsibility
Segregation (CQRS) and configuring NeoVim to be a PHP IDE.</p>

<p>The CQRS talk is really going to be a stealh talk about
paying attention to design patterns. I was asked on Mastodon
for my thoughts on what I felt self-taught programmers were
missing out on compared to those who actually studied computer
science. Being half self-taught (I want to college for computer
studies but before the rise of the web) I could share I felt
self-taught folks tended to reinvent things and to ignore
design patterns.</p>

<p>So I want to teach the audience about design patterns and
cover the ones you are most likely to encounter in their
work building web applications.</p>

<p>The second talk about configuring NeoVim for PHP use is
actually a stealth talk about choosing and matering tools.
I have been a Vim (and now NeoVim user) for many years.
In fact, pretty much every blog post here was written
using Vim or NeoVim. I've used it a lot for PHP development.
But getting to know how to use Vim taught me the importance
of mastering your chosen tools to get the results you 
want faster.</p>

<p>So, I want to suggest strategies for choosing your tools
and some deliberate approaches I have tried that seem to
have worked. I use PhpStorm for most of my PHP work these
days due to great third-party tool integration, but with
Vim keybindings activated. I then use NeoVim for everything
else.</p>

<h2 id="takeaways">Takeaways</h2>

<p>Even though the benefits to both me personally and my career
were immense, I grew bored of giving conference talks. Now
I am determined to do them a lot less but under my own terms.</p>

<p>Maybe I will see some of you in Chicago the last week of
April 2024?</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[A Grumpy Programmer&#039;s Thoughts On LLM]]></title>
            <link href="https://grumpy-learning.com/blog/2024/03/03/grumpy-thoughts-llm/"/>
            <updated>2024-03-03T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/03/03/grumpy-thoughts-llm/</id>
            <content type="html"><![CDATA[<p>I know that I have had a lot of harsh words to say about
"AI" and LLM's lately on my Mastodon account. I thought
I would do a longer piece here on my blog since endless
threads on Mastodon are no substitute for longer-form
writing. Besides, I haven't blogged in two weeks and already
broke my promise to myself of weekly posts here.</p>

<p>Anyway, onwards.</p>

<h2 id="we%27re-being-bamboozled">We're Being Bamboozled</h2>

<p>First off, let's get my main objection out of the way. This
is not Artificial Intelligence in any way, shape, or form.
It is the triumph of marketing and people desperate to grab
dynastic wealth for themselves.</p>

<p>Large Language Models are, in my opinion, very cool technology.
Their ability to take some text written in a more natural language
and generate some output from them is really good. Writing
parsers and interpreters is hard. Making one where the language
you use is not full of weird syntax is even harder.</p>

<p>No, the real issue is that a bunch of people who want to get rich
enough so they never have to interact with us are lying. This is
not artificial intelligence. It is a stochastic parrot, stringing
words together that sound reasonable but very often are full of
shit and not what we asked for.</p>

<p>Since our industry is full of unserious, mediocre people who
think they are competent and serious, the full-press marketing
effort to convince the people who make decisions at companies
across all sorts of industry that "AI is here to make you
easy profits!!!!" is on.</p>

<p>I am not the first person to point out that while the technology
has not gotten to the point where so many people can be replaced
by an LLM, way too many CEO's and other senior leadership have
been convinced that it has reached that point.</p>

<p>The outcome of this is going to be disastrous for any leaders
who have not already figured out how to ensure their compensation
is not tied to the actual performance of their companies.</p>

<h2 id="we%27re-being-told-stealing-is-okay-if-money-is-good">We're Being Told Stealing Is Okay If Money Is Good</h2>

<p>I was there when Napster became a thing. It was awesome to be able
to find all sorts of music you liked and download it to your computer.
I also remember how the music industry freaked out and intended
to sue people for millions of dollars for downloading one song.</p>

<p>As with everything, this freakout was because they had not figured out
a way of making money off the renting of music to people. In our streaming
world, our fate has been sealed -- it is becoming harder and harder to
own "physical" copies of popular items, especially film and music.</p>

<p>But for this new business model of providing natural language prompts that
take our questions and respond with useful answers to work and make monopoly
profits for all involved, they have to read in as much information as possibly
to train their systems. This also means they are brazenly reading in all
sorts of material they do not have permissions to do so.</p>

<p>Then, with a straight face, they tell us we must let them do it or else.</p>

<p>Look, for many years I posted content for free all over the internet. My old
blog (of which the archives are part of this one) and thousands and thousands
of posts to Twitter and Facebook. I understood that as long as I was deliberately
making these posts publicly, I was okay with other people slicing and dicing up
the content.</p>

<p>This is the main premise of the internet I joined and embraced in the early 2000's.</p>

<p>However, I have produced content for which I have been paid. Multiple books, conference
talks, and videos for sale. I am 99.999% sure that books and videos I have created
were slurped up by one of these companies. I did not give them permission. But
given how favourable the US legal system is towards corporations (plus the fact
that I live in Canada) the chances of me getting any kind of compensation for them
making unauthorized copies of what I created is pretty much zero.</p>

<p>They are, from my perspective, thieves wearing business suits or hoodies, depending
on your mental image of what you think an "AI" business owner looks like.</p>

<p>Fuck you, pay me.</p>

<h2 id="scraping-used-to-be-okay">Scraping Used To Be Okay</h2>

<p>To head off some more popular arguments, yes, search engines could not exist without
people giving permission for their content to be scanned, summarized, and categorized.
Again, I am okay with this since by posting my things publicly I gave permission
for this.</p>

<p>It is pretty much impossible to become a programmer with a broad range of skills if
you do not have search engines that accurately answer your prompts. We have questions.
We do not necessarily work or are in close contact with people who have answers. So we
go online and search for those answers.</p>

<p>For a long time, search engines were useful. Then Google, flush with cash and convinced
that having created one incredibly technology, could do anything it wanted. So it used
their incredibly search engine and plastered it with ads to make money. But failure
after failure caused them to lean more and more onto what was now an advertising platform
with a side effect of providing some answers to questions.</p>

<p>Someone much smarter than me has pointed out that LLM's help create the illusion that
so many grifters and non-technical people wanted to believe: that ideas are what mattered
instead of the ability to execute on those ideas.</p>

<p>There is a reason the stereotype of the "bro with an idea who justs needs a technical
person to implement it" persists.</p>

<p>Now, LLM folks believe if we will just shut the hell up and let them steal everything
that isn't nailed down (and take a lot of stuff that is nailed down but nobody is actively
watching) they will no longer need the implementers. Their grand ideas will finally
see the light of day. More importantly, they won't have to share the money with anybody else.</p>

<p>I will not willingly help these people. I am not some cog in their wheel of ambition.</p>

<h2 id="is-there-anything-llm%27s-are-good-for%3F">Is There Anything LLM's Are Good For?</h2>

<p>Of course there are.</p>

<p>One of my co-workers has started using a service called Otter to take transcripts of our meetings at work
so they have reference material. There is nothing revolutionary about taking notes for meetings to
use later. However, it is not a replacement for not attending the meeting. Too many folks
are presenting it as such. Come to the damn meeting and stop acting like you are too
special to be here and discuss the issues with us.</p>

<p>LLM's are providing a lot of value to people as tools to help them solve coding issues.
I am not using them out of choice but I suspect there may come a time when search engines become
enshittified enough that I will have to resort to an LLM to provide me with the skeleton
of solutions to my problems. These sort of tools are nothing more than fancy autocomplete.
There will not be a time any time soon where I can feed it a list of requirements for
a web application and it will create one that works flawlessly and does not need
maintenance.</p>

<p>As a tool for applying a vast number of changes to a code base in a short period of time,
they will be awesome. As a tool to replace someone who understands how to turn natural
language requirements into code? No chance. But too many greedy business owners have
bought the hype and believe they are. I look forward to seeing those businesses suffer
the consequences of poor management.</p>

<h2 id="takeaways">Takeaways</h2>

<p>So, what can we really do?</p>

<p>Well, I think people who work in this industry
like I do can stop hyping it as a replacement for problem solving
and critical thought. These systems do not learn from their mistakes.
They will just keep making them over and over again.</p>

<p>I also feel it is critical to not turn a blind eye to
the fact that these companies are asking us to allow them,
for free, to slurp up everything they find online in an attempt
to sell it back to us.</p>

<p>Given how they fought to have anyone who touched anything that
belonged to them, do not let them off the hook now that stealing
stuff is their best interests.  A lot of these companies have already
been stealing wages from you. Don't let them take anything else.</p>

<p>Finally, understand that being a luddite doesn't mean that you
hate technology -- you hate the exploitation of people via the
use of technology.</p>

<p>Band together. Don't let companies treat you like garbage. Don't
believe the AI hype. This is another bubble and the companies that
are choosing to make the bubble their identity will fail.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[What Was It Like At Mozilla?]]></title>
            <link href="https://grumpy-learning.com/blog/2024/02/17/what-was-it-like-at-mozilla/"/>
            <updated>2024-02-17T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/02/17/what-was-it-like-at-mozilla/</id>
            <content type="html"><![CDATA[<p>I still remember how it all started. Back in September 2015 I got a message
from Laura Thompson about possibly working at Mozilla. Almost 9
years ago. It definitely feels a lot longer than that.</p>

<p>I knew Laura from the PHP community, and they had an opening on
their web services team for a QA person. Working for a large, well-known
company had been on my "professional bucket list" for a very long
time. I took it and stayed there for almost 5 years before getting
let go in the second wave of layoffs in 2020.</p>

<p>During my time there I wrote a lot of Python code. I wrote tests for
web services (if you used Firefox and allowed notifications, I would
test each new release of the notification service to make sure it
all worked as expected as part of my duties), created a distributed
load-testing tool that utilized Kubernetes and Google Cloud Platform,
along with tests for other services.</p>

<p>Things went well until, like any tech company, they shifted priorities.
Several key managers were let go and the group I was in was left to
basically fend for themselves. "Go look for projects that need some
help" was the advice my manager gave me.</p>

<p>That was not great advice. I'm not blaming them -- I am not the easiest
employee to manage. Some of my fellow Mozillians told me things like
"I have the wrong manager" or "they don't know what to do with you".
I am not the easiest
person to manage. I have a weird skill set, I get bored, I don't
hesitate to complain. I make jokes and call bosses "dad" and "mom".
Not everyone likes that sort of stuff, and it did teach me that
ignoring the political game has it's downsides.</p>

<p>For a long time it didn't matter because I worked for Mozilla!
It paid well, I worked from home, I liked my teammates and my
managers over the years (even if they didn't like me). Working
with smart engineers interested in solving hard problems in
repeatable ways is always good.</p>

<p>When I woke up to an email that said I had a 15 minute meeting
with Human Resources in August 2020, I knew I was done. But I wasn't
mad or anything like that. It's just business. The severance was
fair and I found work very quickly. And like that, I took a few months
off to find the next thing and became a "former Mozilla employee".</p>

<p>But that is not what I wanted to talk about.</p>

<p>Earlier this week on Mastodon I did a multi-part post where I tried
to tell people who were complaining about Mozilla and Firefox that
they had no clue about how Mozilla was run or what it takes to create
a web browser.</p>

<p>I mean, why do you think they build testing infrastructure that could
run millions of tests in parallel? I could run tests against whatever version of 
Firefox I needed on multiple operating systems, all from the comfort
of a CLI interface. It was awesome.</p>

<p>Even though Mozilla still champions Open Source Software and wanting
a free and open internet (everyone benefits from this except corporations)
I think it is important to understand how warped goals and incentives
can get there.</p>

<p>The big elephant in the room is, of course, the fact that Mozilla is
the beneficiary of a yearly $400-500 million bribe that Google pays
under the guise of making them the default option for searching if
you use Firefox. Of course, this bribe is really a way for Google to
show what few American regulators who are paying attention that they
don't want a monopoly in the field of web browsers.</p>

<p>I'm not even sure they need to pay it any more. Some day they will
decide to stop and then Mozilla will be no more.</p>

<p>This warped their priorities. All that money without any real accountability
other than "don't piss Google off" I guess.</p>

<p>But what I saw were some folks who were good at leadership, some who
fell into leadership at Mozilla because they were in leadership at
the foundation, and some folks who should've been fired for their
actions but were instead protected.</p>

<p>Look, there was some extremely talented engineers who work there.
I was grateful to be exposed to so many of them, 99% of whom were
happy to help me when I had questions or wanted to learn more.</p>

<p>But it always felt to me like the senior leadership either didn't
understand or didn't care that Mozilla's reputation as a champion
of everything free and open was all they had.</p>

<p>And they constantly did stuff that tore up that reputation.</p>

<ul>
<li>a failed mobile device operating system</li>
<li>Attempts to build paid products led by acquihires who delivered underwhelming and incomplete products</li>
<li>hijacking browser functionality to deliver ads for an American TV show that folks on the marketing side liked</li>
</ul>

<p>Sometimes the people responsible for the failures paid the price.
More often they were patted on the back, allowed to stay, and then
leveraged their roles to move on to other companies. Usually with
more responsibility and I am assuming large pay packages.</p>

<p>After one pretty spectacular failure, I remember an email sent by
one of the senior management people telling us to take it easy
on the people who fucked up because they "tried hard".</p>

<p>But after a while I also saw what happened to the folks who spoke up
about these mistakes. They usually ended up leaving -- either being
pushed or jumping with a hand on their back.</p>

<p>This was not the case for me. I made a strategic error and agreed to
work on a project in a language that I did not know with a team that
did not seem to really want me around. Maybe I was being set up to
fail. Maybe I was sabotaging myself. I wanted to move up in the ranks
and get more money and more responsibility.</p>

<p>Either way, it didn't go well, I floundered and got nothing done, and was
surprised I survived the first wave of layoffs. A lot of people who
I had become friends with (and shared some of my own more troublesome
traits) got let go.</p>

<p>Eventually I did too.</p>

<p>But I did learn a ton there. It was great for learning about the discipline
necessary when working on online systems that literally millions of people
used every day. If you half-assed it, everyone suffered.</p>

<p>I didn't work on the browser at all but I interacted with a lot of people
that did. It's a hard project. You have to maintain so many different
versions across so many different operating systems. Weird bugs. Problems
from operating system vendors. Google deliberating changing their products
to not work well in Firefox.</p>

<p>It is not easy. This is why I get annoyed at people who seem to think building
a web browser out in the open is "easy". They demand their pet features be
given top priority. They moan about old bugs. They moan about the application
not behaving they way they expect. Complain about "selling out" and "telemetry
is an invasion of privacy". An endless stream of complaints.</p>

<p>You have no goddamn idea.</p>

<p>It is so hard to get that across to people convinced they are right. I might
be wrong about a lot of things, but I am not wrong about this part.</p>

<p>Mozilla has warped priorities because of their funding sources.</p>

<p>Firefox is a very difficult project to work on.</p>

<p>I do not regret my time there.</p>

<p>I still believe in an open internet.</p>

<p>I'm just sad that Mozilla is always on the verge of extinction despite so
many great people working hard to live up to the ideals.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Thoughts On Mentoring]]></title>
            <link href="https://grumpy-learning.com/blog/2024/02/04/thoughts-on-mentoring/"/>
            <updated>2024-02-04T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/02/04/thoughts-on-mentoring/</id>
            <content type="html"><![CDATA[<p>Stick around in this industry and you realize that once you
pick a "community", it is quite small. At my current position
with <a href="https://shoppinginsights.ziffdavis.com">Ziff Davis Shopping</a>
my manager is someone who I formally mentored for almost a year
back in the mid 2010's. I really enjoyed sharing my experiences
with him (and another person who became a good friend I never
get to see often enough) as we talked about career goals and how
to make that transition from "programming as a job" to "programming
as a career".</p>

<p>As I am in my early days of being a Staff Software Engineer, a big 
part of the position is a leadership one. Not only am I supposed to
be turning business requirements (and infrastructure requirements)
into code, the decisions I make and the patterns I choose trickle
down to the rest of the team.</p>

<p>Now it may surprise people who have been lulled by my very effective
marketing that the so-called Grumpy Programmer always has lots and
lots of time to give to other programmers who want to learn things
and discuss my work, their work, and how it might fit together.</p>

<p>Since I do enjoy repeatable patterns, here are some things I think
are both repeatable and can lead to success.</p>

<h2 id="if-you-can%27t-explain-it%2C-don%27t-use-it">If You Can't Explain It, Don't Use It</h2>

<p>This is generally good advice for people who want to start giving
talks at conferences (come to Chicago at the end of April and see
me talk about CQRS and how to configure NeoVim to be a PHP IDE at
<a href="https://tek.phparch.com">php[tek] 2024</a>) and even more important
in the workplace.</p>

<p>This is why I try and lean on using established software development
patterns and working as close to the conventions the tools I am using
are expecting. Again, life is too short to fight your software.</p>

<p>Work really hard to only use solutions you can teach other people to
use. I feel like my personal strategy of "small units of code, following
an explainable structure, snapped together like LEGO" is one I can
easily explain.</p>

<h2 id="stop-assuming-everyone-knows-what-you-do">Stop Assuming Everyone Knows What You Do</h2>

<p>This can be hard to do without coming across as condescending or ignorant
but it is critical. "I am using the Repository pattern to create some
classes to talk to the database? Have you used it before?" is a great
example of how to handle it.</p>

<p>I learn something new almost every day from my colleagues, no matter their
levels of experience or perceived skill. I have also found the great side
effect of allowing me to embrace the idea of "what you are doing is complicated
and I don't quite understand it.".</p>

<p>Just because I am a "staff engineer" doesn't mean I understand everything.
I understand enough to prototype and make spikes and then dig deeper for
answers. Never confuse someone not knowing something with them not being
good at their job. I certainly wasn't formally taught design patterns
when I entered the industry in the late 1990's.</p>

<h2 id="embrace-teaching">Embrace Teaching</h2>

<p>Pair with people. Seek feedback on your work. Submit work-in-progress draft
pull requests. Emphasize the parts of your work you are not sure about.
Reiterate the parts that have been successful for others.</p>

<p>I also highly encourage you to embrace the idea of "be the type of co-worker
or leader that you wish you'd had early in your career". I didn't have
anyone mentoring me, so I stumbled around making a lot of mistakes
while ignoring early advice from people that they saw leadership
qualities in me (I have a whole talk ready to go about this if you're
ever interested in having me do a keynote).</p>

<h2 id="take-pride-in-helping">Take Pride In Helping</h2>

<p>Look, I know the phrase <a href="https://en.wikipedia.org/wiki/Servant_leadership">servant leadership</a>
is trendy but the message it it's roots is that as a leader, your job
is to serve the needs of the group you are leading. If you look at it
from the angle of mentoring, your job is to help the people you mentoring
get better. Heck, I try and help people to become better than me.</p>

<p>You never know when you might need help and it's good to know you've
created a network of goodwill around yourself.</p>

<h2 id="takeaways">Takeaways</h2>

<p>After reading this you should learn:</p>

<ul>
<li>I have mentored people in the past</li>
<li>I have enjoyed watching them grow into successful careers</li>
<li>teaching is something I find enjoyable</li>
<li>take pride in having helped people</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[What&#039;s Grumpy Looking At - January 2024]]></title>
            <link href="https://grumpy-learning.com/blog/2024/01/28/grumpy-tech-jan-24/"/>
            <updated>2024-01-28T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/01/28/grumpy-tech-jan-24/</id>
            <content type="html"><![CDATA[<p>I've never been one to stop looking at new tools and figuring
out if they can be applied to the work I do. When do I find
interesting things, I like to talk about them a little and share.
Here's what I've been looking at in January 2024.</p>

<h2 id="laravel">Laravel</h2>

<p>Yes, the artisanal elephant in the room. At my <a href="https://ziffdavis.com">current job</a>
we are all-in on using Laravel. Which means not only learning 
how Laravel does things but evaluating every additional choices
through the lense of "are we going to end up fighting the framework
if we do it this way."</p>

<p>I prefer not to fight. Honestly, it's fine. People are having a
very hard time separating how they feel about the people behind
the tools from the tools themselves. There will always be things to
dislike about any web application framework.</p>

<h2 id="aws">AWS</h2>

<p>A enterprise level company with a large web presence relies heavily
on the cloud? THIS IS MY SHOCKED FACE.</p>

<p>I don't really have to worry much about going into an AWS console
to do something, but I am having to learn about <a href="https://aws.amazon.com/sqs/">SQS</a>
and <a href="https://aws.amazon.com/financial-services/partner-solutions/snowflake/">Snowflake</a>.
More importantly, I get to flex some skills behind building things
that implement interfaces because my work projects will be dealing
with multiple types of queues and multiple data storage back end.</p>

<p>Sometimes code architecture matters instead of being a way for
bored or self-centered-while-misinformed developers to express
themselves.</p>

<h2 id="helix">Helix</h2>

<p>I am a big fan of modal editors as it is very hard to bulid a
keyboard-centric editor without modes. After seeing some <a href="https://neovim.io">NeoVim</a>
folks say nice things about it, I decided to take a look at <a href="https://helix-editor.com">Helix</a>
and see if it is something I could migrate towards.</p>

<p>Lots to like here! Integration with <a href="https://microsoft.github.io/language-server-protocol/">language servers</a>
and <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> along
with being customizable to a certain extent via configuration
files. No plugin architecture yet though.</p>

<p>The show-stopper for me was that it does not have good <a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Anywhere Protocol</a> support, which means I could not get <a href="https://xdebug.org">Xdebug</a>
working with it. Not being able to use an interactive debugger is a
show stopper for me now. Sorry.</p>

<h2 id="hypermedia">Hypermedia</h2>

<p>I talked about it briefly in <a href="https://grumpy-learning.com/blog/2024/01/21/wait-long-enough/">another post here</a>
but I feel like taking a closer look at hypermedia and
acceptable patterns for it might yield some interesting results
in my personal projects. Again, I highly encourage you to
take a look at <a href="https://hypermedia.systems/">Hypermedia Systems</a>.</p>

<h2 id="bootstrap-css">Bootstrap CSS</h2>

<p>CSS and all the associated frameworks is something I also avoided
over the years. My journey into <a href="https://htmx.org/">htmx</a> and hypermedia
also made me take a look at the state of CSS frameworks. My longest-running
project used a very old version of <a href="https://getbootstrap.com">Bootstrap</a> so
rather than pull it all out and replace it with something like
<a href="https://tailwindcss.com">Tailwind</a> (which my brain is having a
hard time wrapping itself around for whatever reason) I'm just back
to older, more stable tools.</p>

<p>When it comes to tools that I do not have a lot of experience with,
I always need a reduced number of choices. Once I've mastered things more
then I appreciate the extensibility and flexibility some tools offer.</p>

<h2 id="takeaways">Takeaways</h2>

<p>After reading this post you should learn:</p>

<ul>
<li>I still like modal editors</li>
<li>I am constantly looking at tools and languages and frameworks for suitability and ease-of-use</li>
<li>sometimes the old ways were actually better instead of triggering nostalgia</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Wait Long Enough And Sometimes Good Things Happen]]></title>
            <link href="https://grumpy-learning.com/blog/2024/01/21/wait-long-enough/"/>
            <updated>2024-01-21T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/01/21/wait-long-enough/</id>
            <content type="html"><![CDATA[<h1 id="wait-long-enough-and-sometimes-good-things-happen...">Wait long enough and sometimes good things happen...</h1>

<p>It can't come as a surprise to anyone that if you are in this
industry long enough, you see trends and tools come and go.
Sometimes you embrace them, sometimes you can dodge them. One
of the things I managed to dodge over the years was having
to do any front-end coding of any substance in JavaScript.</p>

<h2 id="how-did-you-dodge-javascript%3F%21%3F">How did you dodge JavaScript?!?</h2>

<p>If I am being honest, I think it was a combination of two
things. The first was that I began my career helping to
build web sites before AJAX functionality was even a thing.
I distinctly remember the first time a co-worker showed
me a set of interactive form drop-downs built using JavaScript.</p>

<p>"Wow, we don't even have to reload the page?!?! That is cool".</p>

<p>Keep in mind this was 2003.</p>

<p>The second reason I think I was able to dodge JavaScript was
because I made "shouting at people about testing their PHP
code" my career niche at around the same time.</p>

<p>So over the years I kept working as a "backend PHP developer"
who would occasionally modify some JavaScript that I cut-and-paste
from somewhere else. My crowning achievement was creating 
an interface that allowed players to be traded between the
pretend baseball teams in my long-running <a href="https://www.ibl.org">simulation baseball league</a>
by using drag-and-drop.</p>

<h2 id="i-don%27t-hate-javascript%2C-i-just-don%27t-use-it-much">I don't hate JavaScript, I just don't use it much</h2>

<p>Now, this is not to say I didn't pay a little bit of attention
to what the folks who did front-end development were doing. I
was just skeptical that adopting a framework created by Facebook
to solve their needs (React) was going to be a good idea.</p>

<p>My own personal favourite front-end language is <a href="https://elm-lang.org">Elm</a>.
Haskell for the web?!? Sounds awesome. Of course, I had no
projects that needed that kind of work. So I continued to
focus on server-side work and lean heavily on the expertise
of others when it came time to do anything with JavaScript
frameworks.</p>

<p>I also feel like I am in the minority of people who thought
<a href="https://coffeescript.org">CoffeeScript</a> was a great idea.</p>

<p>(Maybe you're starting to see a pattern?)</p>

<p>I think if I was forced to do JavaScript work, I would try
to do it from the warm embrace of <a href="https://www.typescriptlang.org">TypeScript</a>
because I find adding types to be incredibly useful.</p>

<p>During my time doing consulting work for a large avionics
company, their browser-driven test suite relied on
TypeScript. Look, it's fine. JavaScript is similar enough
in syntax to PHP that there are no problems.</p>

<p>Async stuff though, that is weird and I still don't understand
it. Maybe I can dodge that too!</p>

<h2 id="what-did-i-gain-by-waiting%3F">What did I gain by waiting?</h2>

<p>React and Angular have turned out to be, from this grumpy
PHP programmer's perspective, a disaster. They dominate
the industry but from all accounts are not allowing developers
to build experiences that are great for anyone who is not
running powerful devices with lots of available memory.</p>

<p>So I have not done any work with either of those two behemoths.
I'm just this PHP guy, content to work with folks who understand
those tools the same way I understand mine.</p>

<p>After looking longingly at Elm, I waited. After waiting for a
few more years, I kept finding references and going back to
looking at <a href="https://htmx.org">htmx</a>.</p>

<p>Then, as serendipity always does, I saw a <a href="https://mastodon.social/@jakub_zalas/111778943542624692">post on Mastodon</a>
by Jakob Zalas where he mentioned htmx and a great new 
web site promoting some great front-end development
strategies called <a href="https://hypermedia.systems">Hypermedia Systems</a>.</p>

<p>This was a sign that I should go and take a look now. When
a grizzled veteran of programming, who has done great work
in multiple languages talks about a JavaScript framework,
you should probably listen.</p>

<h2 id="takeaways">Takeaways</h2>

<p>After reading this blog post you should know:</p>

<ul>
<li>that I seem to like some weird JavaScript frameworks</li>
<li>I successfully dodged entire generations of tools</li>
<li>I like approaches that use repeatable patterns</li>
<li>I pay attention to the recommendations of other programmers I follow and respect</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[How A Grumpy Programmer Uses View Models]]></title>
            <link href="https://grumpy-learning.com/blog/2024/01/13/view-models/"/>
            <updated>2024-01-13T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/01/13/view-models/</id>
            <content type="html"><![CDATA[<h1 id="how-a-grumpy-programmer-uses-viewmodels">How A Grumpy Programmer Uses ViewModels</h1>

<p>As I've started putting together a talk about <a href="https://en.wikipedia.org/wiki/Command_Query_Responsibility_Segregation">CQRS</a> I noticed that in my own application, I am using
ViewModels in my commands and queries to provide data to
my views.</p>

<p>The purpose of the view model is to sit between our Models
(usually something that talks to a data source) and our views
(usually something that displays data to the screen). As part
of the application architecture I am trying to keep things
separated -- some things should not know about each other.</p>

<p>I discovered the concept of the ViewModel from Matthias Noback's
book "Recipes for Decoupling" where he emphasized the concept
that you should not be passing objects (or anything for that matter)
into your views and templates that they don't need.</p>

<p>There is a whole chapter in this book dedicated to ViewModels. I
can't recommend his book highly enough if you are looking to
create or refactor a project are looking for repeatable processes to keep things
as decoupled as possible.</p>

<p>I think showing how the ViewModel works is best done through
sharing some live, in-production, code with you.</p>

<p>I have a simulation baseball league management application. We
are currently in the middle of our player draft. After some
discussion with the person who handles tracking who was drafted,
I made some changes to the previously-working functionality.
Now I am splitting things into Commands and Queries.</p>

<p>In this case, we have our AssignPlayersToTeamQuery class. This
is a Query, meaning it only reads data and doesn't modify anything.
Here is the code for that Query:</p>

<pre><code class="php">declare(strict_types=1);

namespace Webreg\Query;

use Doctrine\Common\Collections\ArrayCollection;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Twig\Environment;
use Webreg\ViewModel\Franchise;
use Webreg\ViewModel\Roster;

final class AssignPlayersToTeamQuery
{
    public function __construct(
        private Environment $twig,
        private Franchise $franchise,
        private Roster $roster
    ) {}

    public function __invoke(Request $request): Response
    {
        $response = new Response(200, null);
        $parsedBody = $request-&gt;getParsedBody();
        $playersToDraft = new ArrayCollection();

        foreach ($parsedBody['draft'] as $playerId =&gt; $v) {
            $playersToDraft-&gt;add($this-&gt;roster-&gt;getPlayerById($playerId));
        }

        $params = [
            'playersToDraft' =&gt; $playersToDraft,
            'franchises' =&gt; $this-&gt;franchise-&gt;getAll(),
            'round' =&gt; $parsedBody['round'],
        ];
        $response-&gt;getBody()
            -&gt;write($this-&gt;twig-&gt;render(
                'draft/assign_players.twig',
                $params
            )
        );

        return $response;
    }
}
</code></pre>

<p>In an architecture where we don't care that much about
separating concerns, I'd either just return whatever
entity or object my database layer returns or just
convert things to arrays. PHP loves arrays.</p>

<p>However, I don't want to use arrays. I prefer to use
objects and collections wherever I can. So instead
I created a View Model. It's job is to talk to the
database layer and then give me something that my view
layer can use with no modification.</p>

<p>The reason to go with this sort of structure is that
it does allow me to replace things behind the scenes
if I ever change the data source or want to create
a fake for testing purposes.</p>

<p>Okay, let's look at the code for the ViewModel. I created an interface
for any ViewModels dealing with Roster objects to use:</p>

<pre><code class="php">declare(strict_types=1);

namespace Webreg\ViewModel;

use Doctrine\Common\Collections\ArrayCollection;

interface Roster
{
    public function getByTeam(string $iblTeam): ArrayCollection;
}
</code></pre>

<p>Then I implemented a version using that interface.</p>

<pre><code class="php">&lt;?php
declare(strict_types=1);

namespace Webreg\ViewModel;

use Doctrine\Common\Collections\ArrayCollection;
use Pest\Support\Arr;
use Webreg\Repository\RosterRepositoryUsingDoctrine;
use Webreg\Repository\TransactionRepositoryUsingDoctrine;

class RosterUsingDoctrine implements Roster
{
    public function __construct(
        private RosterRepositoryUsingDoctrine $rosterRepository,
        private TransactionRepositoryUsingDoctrine $transactionRepository)
    {}

    public function getByTeam(string $iblTeam): ArrayCollection
    {
        $roster = new ArrayCollection();

        $deactivations = $this-&gt;transactionRepository-&gt;getRecentDeactivationsByTeam($iblTeam);
        $battersFromRepo = $this-&gt;rosterRepository-&gt;getBatters($iblTeam);
        $batters = new ArrayCollection();

        /** @var \Webreg\Domain\Roster $batter */
        foreach ($battersFromRepo as $batter) {
            $deactivationDate = null;

            foreach ($deactivations as $deactivation) {
                if (str_contains(trim($deactivation-&gt;getLogEntry()), trim($batter-&gt;getTigName()))) {
                    $deactivationDate = $deactivation-&gt;getTransactionDate()-&gt;format('Y-m-d');
                }
            }

            $batters-&gt;add([
                'id' =&gt; $batter-&gt;getId(),
                'tigName' =&gt; $batter-&gt;getTigName(),
                'comments' =&gt; $batter-&gt;getComments(),
                'status' =&gt; $batter-&gt;getStatus(),
                'deactivationDate' =&gt; $deactivationDate,
                'uncarded' =&gt; $batter-&gt;getUncarded(),
            ]);
        }
        $roster['batters'] = $batters;

        $pitchersFromRepo = $this-&gt;rosterRepository-&gt;getPitchers($iblTeam); 
        $pitchers = new ArrayCollection();

        /** @var \Webreg\Domain\Roster $pitcher */
        foreach ($pitchersFromRepo as $pitcher) {
            $deactivationDate = null;

            foreach ($deactivations as $deactivation) {
                if (str_contains(trim($deactivation-&gt;getLogEntry()), trim($pitcher-&gt;getTigName()))) {
                    $deactivationDate = $deactivation-&gt;getTransactionDate()-&gt;format('Y-m-d');
                }
            }

            $pitchers-&gt;add([
                'id' =&gt; $pitcher-&gt;getId(),
                'tigName' =&gt; $pitcher-&gt;getTigName(),
                'comments' =&gt; $pitcher-&gt;getComments(),
                'status' =&gt; $pitcher-&gt;getStatus(),
                'deactivationDate' =&gt; $deactivationDate,
                'uncarded' =&gt; $pitcher-&gt;getUncarded(),
            ]);
        }
        $roster['pitchers'] = $pitchers;
        $roster['currentSeason'] = $this-&gt;rosterRepository-&gt;getCurrentSeason();
        $roster['previousSeason'] = $roster['currentSeason'] - 1;

        $picks = new ArrayCollection();

        if ($iblTeam !== 'FA') {
            $picksFromRepo = $this-&gt;rosterRepository-&gt;getPicks($iblTeam);

            /** @var \Webreg\Domain\Roster $pick */
            foreach ($picksFromRepo as $pick) {
                $picks-&gt;add([
                    'id' =&gt; $pick-&gt;getId(),
                    'tigName' =&gt; $pick-&gt;getTigName()
                ]);
            }
        }

        $roster['picks'] = $picks;

        return $roster;
    }

    public function getPlayerById(int $playerId): \Webreg\Domain\Roster
    {
        return $this-&gt;rosterRepository-&gt;getById($playerId);
    }
}
</code></pre>

<p>I should probably also add that <code>getPlayerById</code> method to the
interface as that seems to be functionality I would want no
matter what.</p>

<p>So as you can see, the <code>getPlayerById</code> method returns the result
of a call to our Repository object (which is also based off an
interface, with a Doctrine-specific implementation) to get one
<code>Roster</code> object that maps to our domain.</p>

<p>So, now I have a collection full of the players who can be picked
ready to be passed into my view. I am using <a href="https://twig.symfony.com">Twig</a>
for rendering my views. Luckily for me it is smart enough to look
at what I pass into it and figure out if I am iterating over arrays
or objects.</p>

<p>The concept of the ViewModel is not a new one -- most PHP web application
frameworks just don't use them. They instead lean into the convention of "you
can pass whatever the database layer gives you into your templates". Which
is fine! I just wanted more separation.</p>

<p>If I was doing something different, like writing code that returns JSON results,
I could still use the same repository like in my example, but create a View Model
that implements the same interface but just returns JSON instead of ArrayCollections or
a single Domain record.</p>

<p>I know it seems like a minor thing -- how often are you likely
to change database servers or change what a template outputs?
The reason to go down this route is that you are providing
consistency. Rather than just bang out some code and call it
a day, I've followed a plan and the next person who comes
along and needs something different can look and say "oh, I
just need to implement a new type of ViewModel and the rest
of the code won't care".</p>

<p>If you are going to be at phptek in Chicago this spring I
will be talking about ViewModels and CQRS and decoupling
at the event.</p>

<p>I hope this blog post has done the following:</p>

<ul>
<li>helped you understand what a ViewModel is</li>
<li>when you should consider using them</li>
<li>what does a sample implementation of them look like</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Return on Investment on Updating Dependencies]]></title>
            <link href="https://grumpy-learning.com/blog/2024/01/07/roi-on-updating/"/>
            <updated>2024-01-07T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/01/07/roi-on-updating/</id>
            <content type="html"><![CDATA[<h1 id="return-on-investment-on-updating-dependencies">Return on Investment on Updating Dependencies</h1>

<p>This week I came across two separate posts that seem to
defy what a lot of terminally-online PHP developers have
embraced as common practices:</p>

<ul>
<li><a href="https://alexcabal.com/posts/standard-ebooks-and-classic-web-tech">How Standard Ebooks serves millions of requests per month</a></li>
<li><a href="https://github.com/freescout-helpdesk/freescout/wiki/Development-Guide#maintaining-security-and-laravel-no-upgrade-policy">Freescout's Maintaining Security and Laravel No-Upgrade Policy</a></li>
</ul>

<h2 id="building-things-with-boring-technology">Building things with boring technology</h2>

<p>The Ebooks blog post is a great primer on how to build something awesome
that serves the needs of users without relying on new web application
frameworks that have a lot of dependencies and features that you aren't
going to need. A lot of thought clearly went into "how can we provide
our users with value by using the minimum amount of code and system
resources". Definitely an approach more developers should embrace.</p>

<p>It also emphasizes a point I have been trying to make to programmers: the
people who USE your application will absolutely not care what you are building
it with. What you use is an implementation detail, and the biggest problem
you will face is finding people who can continue to use your chosen implementation
details and keep the application going.</p>

<p>I am going to guess that of the most common scripting languages out there,
PHP is one of the easier ways to accomplish this task. A language born of
the web, with a lot of web-centric functionality as part of it's standard
library, can be used by developers who are familiar with how the web actually
works.</p>

<p>Alex Cabal talks about how when he wants to build something for the web, he
reaches for PHP. Setting aside the obvious conclusion that people who know
PHP well don't hesitate to use it, the only point where he seems to deviate
from my own thoughts is on using web application frameworks.</p>

<p>In his post he calls them "scaffolding that he doesn't want to ever see again"
while I feel like they are the foundation on which you will be forced to
build everything else on.</p>

<p>Sure, you can either use the front-controller pattern implemented in a
framework that intercepts each call and figures out what to do next...or
you can tell Apache to do the same thing. Clearly, the Apache approach
is the "old school" way while most frameworks supply a convention you
need to follow.</p>

<p>I also like the imaginative use of Git to replace the "M" part of the
"LAMP stack" (Linux-Apache-MySql-PHP for those not familiar with the term)
and furthermore the use of storing all their data in memory instead
of the file system.</p>

<p>It's very clear that the folks at Standard Ebooks clearly understand both
the domain and the problems they are trying to solve. It's also very clear
that they learned to write PHP code long before the current situation of
two dominant frameworks pushing new ideas.</p>

<p>Boring is good. Boring allows you to go home on time and also find solutions
to your problems that were created a decade ago.</p>

<h2 id="the-costs-of-updating">The costs of updating</h2>

<p>I have two very long-running PHP applications on the web: one was built using
<a href="https://cakephp.org">CakePHP</a> and the other is free-form PHP that I am slowly
migrating towards having some structure using <a href="https://slimframework.com">Slim</a>.
So I am familiar with not only updating the underlying dependencies AND with
having to have enough actual knowledge of how the web works to write code that
does not heavily rely on a framework (side note: I think the <a href="https://php-fig.org">PHP Standards Recommendations Project</a> is an unjustly-maligned resource for building web applications).</p>

<p>The post from the Freescout folks is a slightly different. In it, they boldly
state that they see no need to update the base framework they used to build
the application. They have instead chosen to update "vendor packages" -- meaning
they are patching the original code provided via Composer.</p>

<p>Their reasoning is similar to what the Ebooks folks are thinking -- the constant
reality of having to update your framework components and (possibly) support
libraries is real. Now, I could argue that with a good test suite in place this
does become a non-issue but I do not know the state of the test suite for either
application.</p>

<p>I do know that it certainly feels like more work to go through dependencies
written by other developers and apply your own custom patches to them. Then
you are stuck maintaining your own custom version of your dependencies.</p>

<p>I don't know -- perhaps I am just lazy and I am more than willing to suffer
the pain of upgrading my dependencies for security fixes or new features
the developers of the framework want you to embrace. Good test suites are
the key and in the absence of them, I hesitate to both do the work myself
or trust the folks writing the application I am using that "we haven't had
any security issues".</p>

<p>Agian, much like in the case of Standard Ebooks, my thoughts on the approach
the Freescout team is taking isn't wildly different or even disparaging.
I just prefer to use other tools to let me know when I need to fix a problem.</p>

<h2 id="takeways">Takeways</h2>

<p>First, don't hesitate to build things with "boring" tools that you understand
well. Your users will literally not care.</p>

<p>Second, there are at a high level two "costs" to using a framework you will have to deal
with. The first is how hard is it to embrace the conventions it uses. The
second is how often are you going to have to devote time and effort to
update both the framework and it's dependencies.</p>

<p>Third, tests are a great tool you can use to find out what breaks and/or
no longer works as expected when you update dependencies.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Asking Companies About Testing]]></title>
            <link href="https://grumpy-learning.com/blog/2022/01/14/asking-companies-about-testing/"/>
            <updated>2022-01-14T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/01/14/asking-companies-about-testing/</id>
            <content type="html"><![CDATA[<p>This post could also be subtitled "The Grumpy Programmer's Guide to Getting Rejected at Interviews".</p>

<p>Someone tagged me in a tweet...</p>

<blockquote>
  <p><em>Book idea for @grmpyprogrammer: an interviewing guide for job seekers wanting to get an idea of how dedicated companies are to testing. Questions to ask, ways to gauge the culture, etc.</em>
  <em>(Originally posted on Twitter at <a href="https://twitter.com/n00bJackleCity/status/1481632465403981824?s=20">https://twitter.com/n00bJackleCity/status/1481632465403981824?s=20</a>)</em></p>
</blockquote>

<p>...and it got me to thinking about where to start with
a request like this one. My personal opinion that there
really isn't a book in here but it did get me to start thinking
about what sort of questions you should be asking.</p>

<p>Again, keep in mind that all of this is just my opinion. One based
on many years of experience, but still an opinion.</p>

<h2 id="why-does-it-matter%3F">Why Does It Matter?</h2>

<p>In my experience, companies that make a commitment to doing automated
testing also tend to make a commitment towards "quality"
in their coding practices and "automation" in their software development tooling.
The reason those are in quotes is because they definitely can mean 
different things depending on the company.</p>

<p>Now, again, in my experience, you are likely to have more success
in solving problems and growing your own skills as a developer if you work
in an environment where they value those things.</p>

<p>After all, just because we can get paid a lot of money to dig in the pixel
mines doesn't mean we should be forced to eat a shit sandwich. We should at 
least have a choice of the additional toppings.</p>

<h2 id="what-questions-should-i-ask%3F">What Questions Should I Ask?</h2>

<p>Like a lot of things related to programming, I find it helpful to start at the
end result you want and work backwards to figure out what needs to be done. Therefore
I think the first two things to ask are:</p>

<blockquote>
  <blockquote>
    <p>What things always have to work when you push changes into production
    and how do you verify that it works as expected?</p>
  </blockquote>
</blockquote>

<p>This question cuts to the heart of the issue: what matters and how do we make
sure it stays that way.</p>

<p>What you are looking for is clear statements about what matters and clearer statements
about how they verify it. Again, not every company has invested the time and money
into having the ability for code changes to seamlessly flow from a development
environment into production, accompanied by effective automated tests and a clear understanding
of outcomes.</p>

<p>If they already have some kind of commitment to testing, asking follow-up questions
like this are also very informative:</p>

<blockquote>
  <blockquote>
    <p>What do you like about your current testing practices and what do you want to change?</p>
  </blockquote>
</blockquote>

<p>Pay as much attention to what they like as what they dislike. That will give you an idea
of what challenges lie ahead if you want to be the person making the changes.</p>

<p>Finally, if you want to find out about what their commitment to quality is, I feel like
a great question is:</p>

<blockquote>
  <blockquote>
    <p>Tell me about how code gets from the developer and up into production</p>
  </blockquote>
</blockquote>

<p>Look for things like:</p>

<ul>
<li>code reviews</li>
<li>coding standards</li>
<li>static code analysis</li>
<li>continuous integration systems</li>
<li>separate staging and production environments</li>
<li>automated deployments</li>
</ul>

<p>Not all of these things are going to guarantee great results (nothing
does and never believe anyone who says it) but, when taken together,
they show a commitment to making sure that:</p>

<ul>
<li>the intent of code is clear</li>
<li>others can understand the code</li>
<li>the code is taking advantage of appropriate language features</li>
<li>the team uses tooling that integrates with version control to automate error-prone manual checklists</li>
<li>application / end-to-end testing happens before it reaches production</li>
<li>repeatable processes ensure consistency</li>
</ul>

<h2 id="so-now-what%3F">So Now What?</h2>

<p>It's hard for me to give any more specific advice other than "don't be 
afraid to ask more questions based on the answers you are hearing." 
If we're being honest, most companies aren't doing all that stuff I listed
above. You can always start at the bottom ("we try and manually test all changes")
and work as hard as you are allowed to on getting to the point where you
have an automated test suite catching issues before your users do.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Solving Problems With Profiling]]></title>
            <link href="https://grumpy-learning.com/blog/2022/01/05/solving-problems-with-profiling/"/>
            <updated>2022-01-05T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/01/05/solving-problems-with-profiling/</id>
            <content type="html"><![CDATA[<p>I was presented with a problem that was occurring in the <a href="https://grumpy-learning.com/blog/2021/12/30/repeatable-dev-environments/">virtual machine</a>
I was using for client development work -- the PHP-based acceptance test suite was running
extremely slowly. Normally it takes 12-13 minutes to run outside of the 
virtual machine but it was taking...54 minutes!</p>

<p>Because I am almost never afraid to ask for help, I bugged <a href="https://twitter.com/ocramius">Marco Pivetta</a>
to give me a hand, since he is working on the same client project. I figured if anyone knew of where to START diagnosing what
the problem is, it would be Marco.</p>

<p>Marco's suggestion after watching a smaller test suite run both in his
local environment and in my VM was that we should run the test suite
with a debugger enabled so we can see what is going on terms of resources
being consumed. For PHP, this usually means using <a href="https://xdebug.org">Xdebug</a>.</p>

<p>What Xdebug allows you to do is:</p>

<ul>
<li><a href="https://xdebug.org/docs/step_debug">step debugging</a></li>
<li>see better <code>var_dump()</code> information</li>
<li>write every function call to disk for later summarizing and reporting</li>
<li>profile your code to look for performance bottlenecks</li>
<li>generate code coverage when using PHPUnit (not sure if it works with other testing frameworks)</li>
</ul>

<p>I've used the step debugging feature a lot on unfamiliar
code bases but the profiling feature was definitely what we needed.</p>

<p>To ask Xdebug to profile the code we're testing, you need to have the
Xdebug extension installed and then tell <a href="https://phpunit.de">PHPUnit</a> that you want
to use it. The command to do it from your shell looks something like
this:</p>

<p><code>XDEBUG_MODE=profile vendor/bin/phpunit --testsuite=unit</code></p>

<p>Because our test environment was configured to run these tests using a specific
Docker container, I had to access the container directly via <code>docker-compose exec php-fpm</code>
and then execute this command inside the container.</p>

<p>This ran the test suite and generated a large number of <a href="https://valgrind.org/docs/manual/cg-manual.html">cachegrind</a>
files. These files contain profiling data but you need a specialized
tool to read them and get information out of them that makes sense.
For Linux users you would likely want to use <a href="https://kcachegrind.github.io">KCachegrind</a>
but luckily for me you can read these files using <a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a>.</p>

<p>The first step was to figure out which of these cachegrind files to 
examine. Unfortunately this is more intuition than science: our test
suite uses <code>@runInSeparateProcess</code> annotations so all the small ones
represent single tests. These are likely not to return any meaningful 
information. "Just pick the biggest one and let's see what happens."</p>

<p>So, we both opened up cachegrind files of similar sizes and took a look
at the data. What exactly where we looking for? In terms of bottlenecks
we can place things in either "network" or "CPU" categories. Is the application
waiting a lot for external resources (say, a service in a different container)
or is it waiting for the CPU to finishing doing something before it 
can continue.</p>

<p>Sadly, I cannot share the cachegrind output here as I have NDA's surrounding
the client work but the approach was:</p>

<ul>
<li>sort the calls by how much time was being spent on executing them</li>
<li>figure out if it is network or CPU</li>
</ul>

<p>For network issues, we were looking for things like time spent connecting
to a MySQL database in another container. As we scrolled through the list
at my end together we started noticing a few things:</p>

<ul>
<li>network access wasn't the problem</li>
<li>we were spending an awful lot of time continually parsing a configuration file written using <a href="https://toml.io/en/">TOML</a> during bootstrap (ticket filed to fix this)</li>
<li>a lot of very simple PHP calls were taking significant amounts of CPU time</li>
</ul>

<p>The next step was to look at how much memory and CPU power I was giving to 
the virtual machine. I was giving it half my processing cores and half the
available memory. So that should not have been an issue.</p>

<p>Marco did some searching and found some forum posts of folks complaining about
how slow some VM's were in the latest version of <a href="https://www.vmware.com/products/fusion.html">VMWare Fusion</a>
but their situation didn't seem to be the same as ours.</p>

<p>"Hrm, Chris, open up that 'Advanced Options' section in the 'Processors &amp; Memory' configuration
section. Aha!"</p>

<p>In that section were two disabled options, both dealing with running containers
inside the virtual machine. Given that we are heavily relying on Docker it definitely
made sense to enable those.</p>

<p>So I shut down the virtual machine, enabled those two options, and started it up.
Much to my surprise, the acceptance test suite now ran in 10 minutes instead of
54 minutes! Huge improvement and is also faster than how long it takes outside
of the virtual machine.</p>

<p>Afterwards, Marco was explaining to me how much Docker relies on having direct memory
access to things so not forcing those connections to go through a different path
in the VM would yield a huge gain. Now I'm happier with the performance of the test
suite.</p>

<p>So, in summary:</p>

<ul>
<li>the test suite was much slower than expected</li>
<li>a decision was made to run the test suite with Xdebug profiling enabled</li>
<li>we made an educated guess as to which profile output file to analyze</li>
<li>the profiling output led us to believe that there was a CPU-related bottleneck</li>
<li>the virtual machine had adequate memory and processor resources allocated to it</li>
<li>the VM was not configured to run containerized applications optimally</li>
<li>the VM has stopped and options pertaining to running containers inside the VM were enabled</li>
<li>re-running the test suite saw a huge increase in performance and execution time</li>
</ul>

<p>Without the ability to profile the code to get a better idea of where there might 
be problems, it would've taken a lot longer to come to an effective solution.</p>
]]></content>
        </entry>
    </feed>