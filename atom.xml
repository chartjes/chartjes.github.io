<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Grumpy Learning]]></title>
    <link href="https://grumpy-learning.com/atom.xml" rel="self"/>
    <link href="https://grumpy-learning.com/"/>
    <updated>2024-02-04T16:40:19+00:00</updated>
    <id>https://grumpy-learning.com/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Thoughts On Mentoring]]></title>
            <link href="https://grumpy-learning.com/blog/2024/02/04/thoughts-on-mentoring/"/>
            <updated>2024-02-04T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/02/04/thoughts-on-mentoring/</id>
            <content type="html"><![CDATA[<p>Stick around in this industry and you realize that once you
pick a "community", it is quite small. At my current position
with <a href="https://shoppinginsights.ziffdavis.com">Ziff Davis Shopping</a>
my manager is someone who I formally mentored for almost a year
back in the mid 2010's. I really enjoyed sharing my experiences
with him (and another person who became a good friend I never
get to see often enough) as we talked about career goals and how
to make that transition from "programming as a job" to "programming
as a career".</p>

<p>As I am in my early days of being a Staff Software Engineer, a big 
part of the position is a leadership one. Not only am I supposed to
be turning business requirements (and infrastructure requirements)
into code, the decisions I make and the patterns I choose trickle
down to the rest of the team.</p>

<p>Now it may surprise people who have been lulled by my very effective
marketing that the so-called Grumpy Programmer always has lots and
lots of time to give to other programmers who want to learn things
and discuss my work, their work, and how it might fit together.</p>

<p>Since I do enjoy repeatable patterns, here are some things I think
are both repeatable and can lead to success.</p>

<h2 id="if-you-can%27t-explain-it%2C-don%27t-use-it">If You Can't Explain It, Don't Use It</h2>

<p>This is generally good advice for people who want to start giving
talks at conferences (come to Chicago at the end of April and see
me talk about CQRS and how to configure NeoVim to be a PHP IDE at
<a href="https://tek.phparch.com">php[tek] 2024</a>) and even more important
in the workplace.</p>

<p>This is why I try and lean on using established software development
patterns and working as close to the conventions the tools I am using
are expecting. Again, life is too short to fight your software.</p>

<p>Work really hard to only use solutions you can teach other people to
use. I feel like my personal strategy of "small units of code, following
an explainable structure, snapped together like LEGO" is one I can
easily explain.</p>

<h2 id="stop-assuming-everyone-knows-what-you-do">Stop Assuming Everyone Knows What You Do</h2>

<p>This can be hard to do without coming across as condescending or ignorant
but it is critical. "I am using the Repository pattern to create some
classes to talk to the database? Have you used it before?" is a great
example of how to handle it.</p>

<p>I learn something new almost every day from my colleagues, no matter their
levels of experience or perceived skill. I have also found the great side
effect of allowing me to embrace the idea of "what you are doing is complicated
and I don't quite understand it.".</p>

<p>Just because I am a "staff engineer" doesn't mean I understand everything.
I understand enough to prototype and make spikes and then dig deeper for
answers. Never confuse someone not knowing something with them not being
good at their job. I certainly wasn't formally taught design patterns
when I entered the industry in the late 1990's.</p>

<h2 id="embrace-teaching">Embrace Teaching</h2>

<p>Pair with people. Seek feedback on your work. Submit work-in-progress draft
pull requests. Emphasize the parts of your work you are not sure about.
Reiterate the parts that have been successful for others.</p>

<p>I also highly encourage you to embrace the idea of "be the type of co-worker
or leader that you wish you'd had early in your career". I didn't have
anyone mentoring me, so I stumbled around making a lot of mistakes
while ignoring early advice from people that they saw leadership
qualities in me (I have a whole talk ready to go about this if you're
ever interested in having me do a keynote).</p>

<h2 id="take-pride-in-helping">Take Pride In Helping</h2>

<p>Look, I know the phrase <a href="https://en.wikipedia.org/wiki/Servant_leadership">servant leadership</a>
is trendy but the message it it's roots is that as a leader, your job
is to serve the needs of the group you are leading. If you look at it
from the angle of mentoring, your job is to help the people you mentoring
get better. Heck, I try and help people to become better than me.</p>

<p>You never know when you might need help and it's good to know you've
created a network of goodwill around yourself.</p>

<h2 id="takeaways">Takeaways</h2>

<p>After reading this you should learn:</p>

<ul>
<li>I have mentored people in the past</li>
<li>I have enjoyed watching them grow into successful careers</li>
<li>teaching is something I find enjoyable</li>
<li>take pride in having helped people</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[What&#039;s Grumpy Looking At - January 2024]]></title>
            <link href="https://grumpy-learning.com/blog/2024/01/28/grumpy-tech-jan-24/"/>
            <updated>2024-01-28T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/01/28/grumpy-tech-jan-24/</id>
            <content type="html"><![CDATA[<p>I've never been one to stop looking at new tools and figuring
out if they can be applied to the work I do. When do I find
interesting things, I like to talk about them a little and share.
Here's what I've been looking at in January 2024.</p>

<h2 id="laravel">Laravel</h2>

<p>Yes, the artisanal elephant in the room. At my <a href="https://ziffdavis.com">current job</a>
we are all-in on using Laravel. Which means not only learning 
how Laravel does things but evaluating every additional choices
through the lense of "are we going to end up fighting the framework
if we do it this way."</p>

<p>I prefer not to fight. Honestly, it's fine. People are having a
very hard time separating how they feel about the people behind
the tools from the tools themselves. There will always be things to
dislike about any web application framework.</p>

<h2 id="aws">AWS</h2>

<p>A enterprise level company with a large web presence relies heavily
on the cloud? THIS IS MY SHOCKED FACE.</p>

<p>I don't really have to worry much about going into an AWS console
to do something, but I am having to learn about <a href="https://aws.amazon.com/sqs/">SQS</a>
and <a href="https://aws.amazon.com/financial-services/partner-solutions/snowflake/">Snowflake</a>.
More importantly, I get to flex some skills behind building things
that implement interfaces because my work projects will be dealing
with multiple types of queues and multiple data storage back end.</p>

<p>Sometimes code architecture matters instead of being a way for
bored or self-centered-while-misinformed developers to express
themselves.</p>

<h2 id="helix">Helix</h2>

<p>I am a big fan of modal editors as it is very hard to bulid a
keyboard-centric editor without modes. After seeing some <a href="https://neovim.io">NeoVim</a>
folks say nice things about it, I decided to take a look at <a href="https://helix-editor.com">Helix</a>
and see if it is something I could migrate towards.</p>

<p>Lots to like here! Integration with <a href="https://microsoft.github.io/language-server-protocol/">language servers</a>
and <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> along
with being customizable to a certain extent via configuration
files. No plugin architecture yet though.</p>

<p>The show-stopper for me was that it does not have good <a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Anywhere Protocol</a> support, which means I could not get <a href="https://xdebug.org">Xdebug</a>
working with it. Not being able to use an interactive debugger is a
show stopper for me now. Sorry.</p>

<h2 id="hypermedia">Hypermedia</h2>

<p>I talked about it briefly in <a href="https://grumpy-learning.com/blog/2024/01/21/wait-long-enough/">another post here</a>
but I feel like taking a closer look at hypermedia and
acceptable patterns for it might yield some interesting results
in my personal projects. Again, I highly encourage you to
take a look at <a href="https://hypermedia.systems/">Hypermedia Systems</a>.</p>

<h2 id="bootstrap-css">Bootstrap CSS</h2>

<p>CSS and all the associated frameworks is something I also avoided
over the years. My journey into <a href="https://htmx.org/">htmx</a> and hypermedia
also made me take a look at the state of CSS frameworks. My longest-running
project used a very old version of <a href="https://getbootstrap.com">Bootstrap</a> so
rather than pull it all out and replace it with something like
<a href="https://tailwindcss.com">Tailwind</a> (which my brain is having a
hard time wrapping itself around for whatever reason) I'm just back
to older, more stable tools.</p>

<p>When it comes to tools that I do not have a lot of experience with,
I always need a reduced number of choices. Once I've mastered things more
then I appreciate the extensibility and flexibility some tools offer.</p>

<h2 id="takeaways">Takeaways</h2>

<p>After reading this post you should learn:</p>

<ul>
<li>I still like modal editors</li>
<li>I am constantly looking at tools and languages and frameworks for suitability and ease-of-use</li>
<li>sometimes the old ways were actually better instead of triggering nostalgia</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Wait Long Enough And Sometimes Good Things Happen]]></title>
            <link href="https://grumpy-learning.com/blog/2024/01/21/wait-long-enough/"/>
            <updated>2024-01-21T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/01/21/wait-long-enough/</id>
            <content type="html"><![CDATA[<h1 id="wait-long-enough-and-sometimes-good-things-happen...">Wait long enough and sometimes good things happen...</h1>

<p>It can't come as a surprise to anyone that if you are in this
industry long enough, you see trends and tools come and go.
Sometimes you embrace them, sometimes you can dodge them. One
of the things I managed to dodge over the years was having
to do any front-end coding of any substance in JavaScript.</p>

<h2 id="how-did-you-dodge-javascript%3F%21%3F">How did you dodge JavaScript?!?</h2>

<p>If I am being honest, I think it was a combination of two
things. The first was that I began my career helping to
build web sites before AJAX functionality was even a thing.
I distinctly remember the first time a co-worker showed
me a set of interactive form drop-downs built using JavaScript.</p>

<p>"Wow, we don't even have to reload the page?!?! That is cool".</p>

<p>Keep in mind this was 2003.</p>

<p>The second reason I think I was able to dodge JavaScript was
because I made "shouting at people about testing their PHP
code" my career niche at around the same time.</p>

<p>So over the years I kept working as a "backend PHP developer"
who would occasionally modify some JavaScript that I cut-and-paste
from somewhere else. My crowning achievement was creating 
an interface that allowed players to be traded between the
pretend baseball teams in my long-running <a href="https://www.ibl.org">simulation baseball league</a>
by using drag-and-drop.</p>

<h2 id="i-don%27t-hate-javascript%2C-i-just-don%27t-use-it-much">I don't hate JavaScript, I just don't use it much</h2>

<p>Now, this is not to say I didn't pay a little bit of attention
to what the folks who did front-end development were doing. I
was just skeptical that adopting a framework created by Facebook
to solve their needs (React) was going to be a good idea.</p>

<p>My own personal favourite front-end language is <a href="https://elm-lang.org">Elm</a>.
Haskell for the web?!? Sounds awesome. Of course, I had no
projects that needed that kind of work. So I continued to
focus on server-side work and lean heavily on the expertise
of others when it came time to do anything with JavaScript
frameworks.</p>

<p>I also feel like I am in the minority of people who thought
<a href="https://coffeescript.org">CoffeeScript</a> was a great idea.</p>

<p>(Maybe you're starting to see a pattern?)</p>

<p>I think if I was forced to do JavaScript work, I would try
to do it from the warm embrace of <a href="https://www.typescriptlang.org">TypeScript</a>
because I find adding types to be incredibly useful.</p>

<p>During my time doing consulting work for a large avionics
company, their browser-driven test suite relied on
TypeScript. Look, it's fine. JavaScript is similar enough
in syntax to PHP that there are no problems.</p>

<p>Async stuff though, that is weird and I still don't understand
it. Maybe I can dodge that too!</p>

<h2 id="what-did-i-gain-by-waiting%3F">What did I gain by waiting?</h2>

<p>React and Angular have turned out to be, from this grumpy
PHP programmer's perspective, a disaster. They dominate
the industry but from all accounts are not allowing developers
to build experiences that are great for anyone who is not
running powerful devices with lots of available memory.</p>

<p>So I have not done any work with either of those two behemoths.
I'm just this PHP guy, content to work with folks who understand
those tools the same way I understand mine.</p>

<p>After looking longingly at Elm, I waited. After waiting for a
few more years, I kept finding references and going back to
looking at <a href="https://htmx.org">htmx</a>.</p>

<p>Then, as serendipity always does, I saw a <a href="https://mastodon.social/@jakub_zalas/111778943542624692">post on Mastodon</a>
by Jakob Zalas where he mentioned htmx and a great new 
web site promoting some great front-end development
strategies called <a href="https://hypermedia.systems">Hypermedia Systems</a>.</p>

<p>This was a sign that I should go and take a look now. When
a grizzled veteran of programming, who has done great work
in multiple languages talks about a JavaScript framework,
you should probably listen.</p>

<h2 id="takeaways">Takeaways</h2>

<p>After reading this blog post you should know:</p>

<ul>
<li>that I seem to like some weird JavaScript frameworks</li>
<li>I successfully dodged entire generations of tools</li>
<li>I like approaches that use repeatable patterns</li>
<li>I pay attention to the recommendations of other programmers I follow and respect</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[How A Grumpy Programmer Uses View Models]]></title>
            <link href="https://grumpy-learning.com/blog/2024/01/13/view-models/"/>
            <updated>2024-01-13T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/01/13/view-models/</id>
            <content type="html"><![CDATA[<h1 id="how-a-grumpy-programmer-uses-viewmodels">How A Grumpy Programmer Uses ViewModels</h1>

<p>As I've started putting together a talk about <a href="https://en.wikipedia.org/wiki/Command_Query_Responsibility_Segregation">CQRS</a> I noticed that in my own application, I am using
ViewModels in my commands and queries to provide data to
my views.</p>

<p>The purpose of the view model is to sit between our Models
(usually something that talks to a data source) and our views
(usually something that displays data to the screen). As part
of the application architecture I am trying to keep things
separated -- some things should not know about each other.</p>

<p>I discovered the concept of the ViewModel from Matthias Noback's
book "Recipes for Decoupling" where he emphasized the concept
that you should not be passing objects (or anything for that matter)
into your views and templates that they don't need.</p>

<p>There is a whole chapter in this book dedicated to ViewModels. I
can't recommend his book highly enough if you are looking to
create or refactor a project are looking for repeatable processes to keep things
as decoupled as possible.</p>

<p>I think showing how the ViewModel works is best done through
sharing some live, in-production, code with you.</p>

<p>I have a simulation baseball league management application. We
are currently in the middle of our player draft. After some
discussion with the person who handles tracking who was drafted,
I made some changes to the previously-working functionality.
Now I am splitting things into Commands and Queries.</p>

<p>In this case, we have our AssignPlayersToTeamQuery class. This
is a Query, meaning it only reads data and doesn't modify anything.
Here is the code for that Query:</p>

<pre><code class="php">declare(strict_types=1);

namespace Webreg\Query;

use Doctrine\Common\Collections\ArrayCollection;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Twig\Environment;
use Webreg\ViewModel\Franchise;
use Webreg\ViewModel\Roster;

final class AssignPlayersToTeamQuery
{
    public function __construct(
        private Environment $twig,
        private Franchise $franchise,
        private Roster $roster
    ) {}

    public function __invoke(Request $request): Response
    {
        $response = new Response(200, null);
        $parsedBody = $request-&gt;getParsedBody();
        $playersToDraft = new ArrayCollection();

        foreach ($parsedBody['draft'] as $playerId =&gt; $v) {
            $playersToDraft-&gt;add($this-&gt;roster-&gt;getPlayerById($playerId));
        }

        $params = [
            'playersToDraft' =&gt; $playersToDraft,
            'franchises' =&gt; $this-&gt;franchise-&gt;getAll(),
            'round' =&gt; $parsedBody['round'],
        ];
        $response-&gt;getBody()
            -&gt;write($this-&gt;twig-&gt;render(
                'draft/assign_players.twig',
                $params
            )
        );

        return $response;
    }
}
</code></pre>

<p>In an architecture where we don't care that much about
separating concerns, I'd either just return whatever
entity or object my database layer returns or just
convert things to arrays. PHP loves arrays.</p>

<p>However, I don't want to use arrays. I prefer to use
objects and collections wherever I can. So instead
I created a View Model. It's job is to talk to the
database layer and then give me something that my view
layer can use with no modification.</p>

<p>The reason to go with this sort of structure is that
it does allow me to replace things behind the scenes
if I ever change the data source or want to create
a fake for testing purposes.</p>

<p>Okay, let's look at the code for the ViewModel. I created an interface
for any ViewModels dealing with Roster objects to use:</p>

<pre><code class="php">declare(strict_types=1);

namespace Webreg\ViewModel;

use Doctrine\Common\Collections\ArrayCollection;

interface Roster
{
    public function getByTeam(string $iblTeam): ArrayCollection;
}
</code></pre>

<p>Then I implemented a version using that interface.</p>

<pre><code class="php">&lt;?php
declare(strict_types=1);

namespace Webreg\ViewModel;

use Doctrine\Common\Collections\ArrayCollection;
use Pest\Support\Arr;
use Webreg\Repository\RosterRepositoryUsingDoctrine;
use Webreg\Repository\TransactionRepositoryUsingDoctrine;

class RosterUsingDoctrine implements Roster
{
    public function __construct(
        private RosterRepositoryUsingDoctrine $rosterRepository,
        private TransactionRepositoryUsingDoctrine $transactionRepository)
    {}

    public function getByTeam(string $iblTeam): ArrayCollection
    {
        $roster = new ArrayCollection();

        $deactivations = $this-&gt;transactionRepository-&gt;getRecentDeactivationsByTeam($iblTeam);
        $battersFromRepo = $this-&gt;rosterRepository-&gt;getBatters($iblTeam);
        $batters = new ArrayCollection();

        /** @var \Webreg\Domain\Roster $batter */
        foreach ($battersFromRepo as $batter) {
            $deactivationDate = null;

            foreach ($deactivations as $deactivation) {
                if (str_contains(trim($deactivation-&gt;getLogEntry()), trim($batter-&gt;getTigName()))) {
                    $deactivationDate = $deactivation-&gt;getTransactionDate()-&gt;format('Y-m-d');
                }
            }

            $batters-&gt;add([
                'id' =&gt; $batter-&gt;getId(),
                'tigName' =&gt; $batter-&gt;getTigName(),
                'comments' =&gt; $batter-&gt;getComments(),
                'status' =&gt; $batter-&gt;getStatus(),
                'deactivationDate' =&gt; $deactivationDate,
                'uncarded' =&gt; $batter-&gt;getUncarded(),
            ]);
        }
        $roster['batters'] = $batters;

        $pitchersFromRepo = $this-&gt;rosterRepository-&gt;getPitchers($iblTeam); 
        $pitchers = new ArrayCollection();

        /** @var \Webreg\Domain\Roster $pitcher */
        foreach ($pitchersFromRepo as $pitcher) {
            $deactivationDate = null;

            foreach ($deactivations as $deactivation) {
                if (str_contains(trim($deactivation-&gt;getLogEntry()), trim($pitcher-&gt;getTigName()))) {
                    $deactivationDate = $deactivation-&gt;getTransactionDate()-&gt;format('Y-m-d');
                }
            }

            $pitchers-&gt;add([
                'id' =&gt; $pitcher-&gt;getId(),
                'tigName' =&gt; $pitcher-&gt;getTigName(),
                'comments' =&gt; $pitcher-&gt;getComments(),
                'status' =&gt; $pitcher-&gt;getStatus(),
                'deactivationDate' =&gt; $deactivationDate,
                'uncarded' =&gt; $pitcher-&gt;getUncarded(),
            ]);
        }
        $roster['pitchers'] = $pitchers;
        $roster['currentSeason'] = $this-&gt;rosterRepository-&gt;getCurrentSeason();
        $roster['previousSeason'] = $roster['currentSeason'] - 1;

        $picks = new ArrayCollection();

        if ($iblTeam !== 'FA') {
            $picksFromRepo = $this-&gt;rosterRepository-&gt;getPicks($iblTeam);

            /** @var \Webreg\Domain\Roster $pick */
            foreach ($picksFromRepo as $pick) {
                $picks-&gt;add([
                    'id' =&gt; $pick-&gt;getId(),
                    'tigName' =&gt; $pick-&gt;getTigName()
                ]);
            }
        }

        $roster['picks'] = $picks;

        return $roster;
    }

    public function getPlayerById(int $playerId): \Webreg\Domain\Roster
    {
        return $this-&gt;rosterRepository-&gt;getById($playerId);
    }
}
</code></pre>

<p>I should probably also add that <code>getPlayerById</code> method to the
interface as that seems to be functionality I would want no
matter what.</p>

<p>So as you can see, the <code>getPlayerById</code> method returns the result
of a call to our Repository object (which is also based off an
interface, with a Doctrine-specific implementation) to get one
<code>Roster</code> object that maps to our domain.</p>

<p>So, now I have a collection full of the players who can be picked
ready to be passed into my view. I am using <a href="https://twig.symfony.com">Twig</a>
for rendering my views. Luckily for me it is smart enough to look
at what I pass into it and figure out if I am iterating over arrays
or objects.</p>

<p>The concept of the ViewModel is not a new one -- most PHP web application
frameworks just don't use them. They instead lean into the convention of "you
can pass whatever the database layer gives you into your templates". Which
is fine! I just wanted more separation.</p>

<p>If I was doing something different, like writing code that returns JSON results,
I could still use the same repository like in my example, but create a View Model
that implements the same interface but just returns JSON instead of ArrayCollections or
a single Domain record.</p>

<p>I know it seems like a minor thing -- how often are you likely
to change database servers or change what a template outputs?
The reason to go down this route is that you are providing
consistency. Rather than just bang out some code and call it
a day, I've followed a plan and the next person who comes
along and needs something different can look and say "oh, I
just need to implement a new type of ViewModel and the rest
of the code won't care".</p>

<p>If you are going to be at phptek in Chicago this spring I
will be talking about ViewModels and CQRS and decoupling
at the event.</p>

<p>I hope this blog post has done the following:</p>

<ul>
<li>helped you understand what a ViewModel is</li>
<li>when you should consider using them</li>
<li>what does a sample implementation of them look like</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Return on Investment on Updating Dependencies]]></title>
            <link href="https://grumpy-learning.com/blog/2024/01/07/roi-on-updating/"/>
            <updated>2024-01-07T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2024/01/07/roi-on-updating/</id>
            <content type="html"><![CDATA[<h1 id="return-on-investment-on-updating-dependencies">Return on Investment on Updating Dependencies</h1>

<p>This week I came across two separate posts that seem to
defy what a lot of terminally-online PHP developers have
embraced as common practices:</p>

<ul>
<li><a href="https://alexcabal.com/posts/standard-ebooks-and-classic-web-tech">How Standard Ebooks serves millions of requests per month</a></li>
<li><a href="https://github.com/freescout-helpdesk/freescout/wiki/Development-Guide#maintaining-security-and-laravel-no-upgrade-policy">Freescout's Maintaining Security and Laravel No-Upgrade Policy</a></li>
</ul>

<h2 id="building-things-with-boring-technology">Building things with boring technology</h2>

<p>The Ebooks blog post is a great primer on how to build something awesome
that serves the needs of users without relying on new web application
frameworks that have a lot of dependencies and features that you aren't
going to need. A lot of thought clearly went into "how can we provide
our users with value by using the minimum amount of code and system
resources". Definitely an approach more developers should embrace.</p>

<p>It also emphasizes a point I have been trying to make to programmers: the
people who USE your application will absolutely not care what you are building
it with. What you use is an implementation detail, and the biggest problem
you will face is finding people who can continue to use your chosen implementation
details and keep the application going.</p>

<p>I am going to guess that of the most common scripting languages out there,
PHP is one of the easier ways to accomplish this task. A language born of
the web, with a lot of web-centric functionality as part of it's standard
library, can be used by developers who are familiar with how the web actually
works.</p>

<p>Alex Cabal talks about how when he wants to build something for the web, he
reaches for PHP. Setting aside the obvious conclusion that people who know
PHP well don't hesitate to use it, the only point where he seems to deviate
from my own thoughts is on using web application frameworks.</p>

<p>In his post he calls them "scaffolding that he doesn't want to ever see again"
while I feel like they are the foundation on which you will be forced to
build everything else on.</p>

<p>Sure, you can either use the front-controller pattern implemented in a
framework that intercepts each call and figures out what to do next...or
you can tell Apache to do the same thing. Clearly, the Apache approach
is the "old school" way while most frameworks supply a convention you
need to follow.</p>

<p>I also like the imaginative use of Git to replace the "M" part of the
"LAMP stack" (Linux-Apache-MySql-PHP for those not familiar with the term)
and furthermore the use of storing all their data in memory instead
of the file system.</p>

<p>It's very clear that the folks at Standard Ebooks clearly understand both
the domain and the problems they are trying to solve. It's also very clear
that they learned to write PHP code long before the current situation of
two dominant frameworks pushing new ideas.</p>

<p>Boring is good. Boring allows you to go home on time and also find solutions
to your problems that were created a decade ago.</p>

<h2 id="the-costs-of-updating">The costs of updating</h2>

<p>I have two very long-running PHP applications on the web: one was built using
<a href="https://cakephp.org">CakePHP</a> and the other is free-form PHP that I am slowly
migrating towards having some structure using <a href="https://slimframework.com">Slim</a>.
So I am familiar with not only updating the underlying dependencies AND with
having to have enough actual knowledge of how the web works to write code that
does not heavily rely on a framework (side note: I think the <a href="https://php-fig.org">PHP Standards Recommendations Project</a> is an unjustly-maligned resource for building web applications).</p>

<p>The post from the Freescout folks is a slightly different. In it, they boldly
state that they see no need to update the base framework they used to build
the application. They have instead chosen to update "vendor packages" -- meaning
they are patching the original code provided via Composer.</p>

<p>Their reasoning is similar to what the Ebooks folks are thinking -- the constant
reality of having to update your framework components and (possibly) support
libraries is real. Now, I could argue that with a good test suite in place this
does become a non-issue but I do not know the state of the test suite for either
application.</p>

<p>I do know that it certainly feels like more work to go through dependencies
written by other developers and apply your own custom patches to them. Then
you are stuck maintaining your own custom version of your dependencies.</p>

<p>I don't know -- perhaps I am just lazy and I am more than willing to suffer
the pain of upgrading my dependencies for security fixes or new features
the developers of the framework want you to embrace. Good test suites are
the key and in the absence of them, I hesitate to both do the work myself
or trust the folks writing the application I am using that "we haven't had
any security issues".</p>

<p>Agian, much like in the case of Standard Ebooks, my thoughts on the approach
the Freescout team is taking isn't wildly different or even disparaging.
I just prefer to use other tools to let me know when I need to fix a problem.</p>

<h2 id="takeways">Takeways</h2>

<p>First, don't hesitate to build things with "boring" tools that you understand
well. Your users will literally not care.</p>

<p>Second, there are at a high level two "costs" to using a framework you will have to deal
with. The first is how hard is it to embrace the conventions it uses. The
second is how often are you going to have to devote time and effort to
update both the framework and it's dependencies.</p>

<p>Third, tests are a great tool you can use to find out what breaks and/or
no longer works as expected when you update dependencies.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Talks with secret topics]]></title>
            <link href="https://grumpy-learning.com/blog/2023/12/29/secret-talks/"/>
            <updated>2023-12-29T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/12/29/secret-talks/</id>
            <content type="html"><![CDATA[<h1 id="talks-with-secret-topics">Talks With Secret Topics</h1>

<p>I've been speaking at conferences since 2005. Yes, that is
a ridiculously long time. While these talks have mostly been
about testing practices, I enjoy creating talks that actually
have a secret topic in them. It's usually related to the main
topic, but given I usually have 60 minutes to fill I feel like
I need to give the attendees a glimpse into how my grumpy mind
works.</p>

<p>Many of my testing talks end up covering one of more "secret
topics":</p>

<ul>
<li>defensive coding styles</li>
<li>third party tools to apply consistency</li>
<li>design patterns</li>
<li>how luck is just really skill and opportunity intersecting</li>
</ul>

<p>On the one hand, I have a captive audience forced to listen to me.
On the other hand, I do like to be entertaining and informative.
Choosing this "secret topic" style allows me to embrace what
I feel are the good parts of me:</p>

<ul>
<li>loves to talk</li>
<li>has seen so so many good and bad things in his career</li>
<li>wants to help people learn faster than I did with less suffering</li>
</ul>

<p>I will be speaking at <a href="https://tek.phparch.com">php[tek] 2024</a> in
Chicago at the end of April. After speaking at LonghornPHP in 2022
I had decided to no longer do testing talks. I've been doing them
since 2005. 18 years is enough. Please. No more.</p>

<p>I got selected to give two talks, none of which are testing related.
I want to share what those talks are probably going to look like. I
don't have them written yet but I have the outline rattling around
inside my head and it will get turned into slides and (in a newer twist)
some live coding to go with it.</p>

<h2 id="cqrs-talk...-that-is-really-about-web-site-architectures">CQRS talk... that is really about web site architectures</h2>

<p>My first talk is "Break loose from CRUD - use CQRS" where I will show
how I refactored a legacy PHP application that was a mess using the
Command Query Responsibility Segregation pattern.</p>

<p>In order to understand why we have more options that the "traditional"
Create Read Update Delete (or CRUD) pattern that ties our implementation
to database-related actions, I plan on doing a brief history of architectures
that can be used with web applications. I think a lot of folks simply
are not aware of the different options available to them due the domination
of modern PHP web application frameworks by a few <a href="https://laravel.com">big</a>
<a href="https://symfony.com">players</a>.</p>

<p>I chose CQRS for a project because it had been related to another topic
(<a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>]
that other much-smarter programmers than me had been talking about.</p>

<h2 id="neovim-as-php-ide-talk...that-is-really-about-mastering-tools">NeoVim-as-PHP-IDE talk...that is really about mastering tools</h2>

<p>My second talk is about my <a href="https://neovim.io">NeoVim</a> setup for doing
PHP work. I also use <a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a> a lot
for my PHP work, but it's good to have options.</p>

<p>I learned how to use Vim almost 20 years ago but dabbled constantly with
other editors. Some of it was tribalism, some of it was my restlessness
with the status quo. I've used Vim/NeoVim for so long that my muscle
memory is strong enough to ruin working inside tools that do not support
Vim bindings or modal editing.</p>

<p>NeoVim being completely customizable forces you down the road of thoughtful
customization -- since so many things are possible, and not constrained
by NeoVim itself, you are responsible for figuring out what you want your
IDE experience to be like.</p>

<p>So this talk will cover my own path to selecting and mastering tools.
Understanding the limitations of something is the best way to push it
in the direction you really want it to go.</p>

<h2 id="secret-talks-require-confidence">Secret Talks Require Confidence</h2>

<p>It's no secret that I carry myself with a lot of confidence -- the whole
Grumpy Learning brand would not have worked without it. When you also
decide to create secret talks, you need to have the ability to tell a
story and weave different elements together to constantly reinforce
the overall message.</p>

<p>I don't think this technique is for everybody -- it requires being
comfortable with the idea that there is a lot of background information
that is relevant to the topic your talk is supposed to be covering.</p>

<p>At this point, I don't think I could build talks any other way and still
be true to myself.</p>

<p>I hope to see you at tek2024!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Reducing Friction in Development Environments]]></title>
            <link href="https://grumpy-learning.com/blog/2023/09/29/reducing-friction-in-development-environments/"/>
            <updated>2023-09-29T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/09/29/reducing-friction-in-development-environments/</id>
            <content type="html"><![CDATA[<h1 id="reducing-friction-in-development-environments">Reducing Friction in Development Environments</h1>

<p>As my 27th year of getting paid to create web applications
starts to wind down, I reflect on how hard I work to try
and create a development environment experience (heh, that
sounds so pretentious when spoken out loud!) that has as
little friction as possible.</p>

<p>Late in 2023, what does that look like for me?</p>

<h2 id="learn-your-editor">Learn your editor</h2>

<p>I have lost count of the number of editors I have used over
the years. Some I would never touch again. Some I felt changed
how people built all future editors. If it was available for
my Mac, I was at least trying it out.</p>

<p>One thing that did eventually change was that I
settled on one editor (well, sort-of) and dedicated time
to exploring it's other features beyond just editing text.</p>

<p>Just to be clear, I really don't care what editor you use.
I just think you should pick one and learn it really well.</p>

<p>I do flip back and forth between <a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a>
and <a href="https://neovim.io">NeoVim</a>, depending on the task.
Years of using Vim and NeoVim has imprinted both modal
editing and Vim keybindings into my muscle memory, so
I have Vim bindings installed for PhpStorm.</p>

<p>If your editor has an extensive list of keyboard shortcuts,
take the time to learn all the common ones. While I'm
not some kind of productivity grifter, I do feel like reducing
the number of times your hands leave your keyboard can
only be a good thing.</p>

<p>I should probably stop grabbing my phone so much too.</p>

<p>Learning how to use your editor and how easily it can integrate
with other tools is, for me, the first step towards reducing
friction.</p>

<h2 id="repeatability">Repeatability</h2>

<p>"Works on my machine" is both a joke and a reality when you do
development work. Here are some solutions I recommend:</p>

<ul>
<li><a href="https://www.docker.com">Docker</a> to create containers that duplicate production</li>
<li><a href="https://nixos.org/">Nix and NixOS</a> to make reproducible systems</li>
</ul>

<p>The bottom line is that you can reduce friction by adopting
tools that allow other people to use the same dependencies
that you are using. Yes, it can be annoying and frustrating
to get thing "just right", along with duplicating a production
environments that relies on a ton of services. But once you
have it as close to production as possible, the time to get
code out of your development environment and into production
is greatly reduced.</p>

<h2 id="standards">Standards</h2>

<p>Coding standards make sure your code all looks the same. I should
not be able to figure out who wrote some code by looking at it.
Static code analysis applies standards in terms of how the code
you wrote should be used by others. Testing standards ensure
that you have confidence that the code you wrote will continue
to behave in the way you expect it to.</p>

<h2 id="automation">Automation</h2>

<p>For me, this is the one that I think a lot of developers need
to embrace more. Write small shell scripts to execute multiple
commands that you type into your CLI. Use Makefiles. Add things
to your <code>composer.json</code> file so you can type <code>composer test</code>
and have the tests run.</p>

<p>Everything you can do to automate repetitive tasks is one less
thing you have to remember. I'd rather be working on solving
a business-related problem than remembering what order I need
to run these 10 commands to get my code from my laptop and into
production.</p>

<h2 id="willingness-to-learn">Willingness to Learn</h2>

<p>I don't know how typical I am in terms of evaluating my tools
and techniques on a regular basis, but I feel like my willingness
to learn new things and try out new tools that solve old problems
has really helped me reduce friction.</p>

<p>Except for rebasing things in Git. That still gives me so many
problems and I will go to my post-programming life insisting
that version control systems do not need to be so complicated.</p>

<h2 id="too-much-friction-causes-fires">Too Much Friction Causes Fires</h2>

<p>I think my over-arching point is that the tools you use to
write code every day should not cause you problems. It's entirely
possible I have learned to ignore the rough edges my tools
present (Vim certainly has a steep learning curve) but I truly
work on making sure a computer does repetitive actions for me
as much as possible. It's not going to complain about it to me.</p>

<p>I hope I've gotten you to start evaluating or re-evaluating your
chosen tools and find some new-or-different ways to reduce
any friction you are finding in your development environments
and processes.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Deciding How To Test Bug Fixes]]></title>
            <link href="https://grumpy-learning.com/blog/2023/05/03/deciding-how-to-test-bug-fixes/"/>
            <updated>2023-05-03T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/05/03/deciding-how-to-test-bug-fixes/</id>
            <content type="html"><![CDATA[<h1 id="deciding-how-to-test-bug-fixes">Deciding How To Test Bug Fixes</h1>

<p>"Hey Chris, I see that when Rusty went and updated his rotation for this
week, there are two entries. Looks like a bug."</p>

<p>For my <a href="https://www.ibl.org">other hobby</a> I also created a series of
old-school-spaghetti-and-lasagna-style PHP scripts for doing the
job of keeping track of rosters, player movement, and potential
pitching rotations. It was a mess. I was initially inspired by
Rasmus Lerdorf's <a href="https://toys.lerdorf.com/the-no-framework-php-mvc-framework">"The no-framework PHP MVC framework"</a>
blog post. I did a really bad implementation.</p>

<p>But that was okay, because only a few people used it and I
had extensive domain knowledge that made figuring out what
the expected behaviour was supposed to be.</p>

<p>While I was <a href="https://www.investopedia.com/terms/f/funemployment.asp">funemployed</a> during December 2022
I decided to go back and apply some structure to this application.
It became a <a href="https://www.slimframework.com">Slim</a> + <a href="https://www.doctrine-project.org">Doctrine</a>
application and I started working on refactoring it while also
making sure existing functionality behaved as expected.</p>

<p>It had very few tests and I did set about writing tests for the
refactored versions because who wants bugs? Except I forgot to
do some for some refactored functionality.</p>

<p>At a high level, here is the bug:</p>

<ul>
<li>a user is presented with a form to add free-form text to specific rows</li>
<li>when they click on the Save button, it is supposed to update details</li>
<li>it was instead adding new details, not updating</li>
</ul>

<p>No problem, I can fix this (and re-learn some things I had forgotten
about Doctrine) and will also test this.</p>

<h2 id="manual-vs.-automated">Manual vs. Automated</h2>

<p>As many people who have listened to me talk, in my opinion there is
a constant tension between "testing things manually" and "writing
an automated test". Sometimes this tension is because the people
involved are lazy. Sometimes it is due to time constraints. Sometimes
it's because the current system is difficult to test in an automated
way.</p>

<p>In this case I actually had two choices. I could work on code changes
and manually test them using the application itself. This is actually
how I normally do work on this particular application.</p>

<p>(As an aside, my normal policy is "if you pay me, I will automate
as much of the testing as I can". For hobby projects I literally
do whatever I feel like)</p>

<p>After looking at the refactored code, I realized that I would have
to make a bunch of changes so this was a great opportunity to create
an automated test that uses a real database.</p>

<p>This is very low-risk for this project as I am doing 99% of the
development work on this code base. There is no build server running
a series of checks. I need the real database to be there for me to
test out the "customer-facing" side of this application so no new
infrastructure is needed.</p>

<h2 id="real-tests">Real Tests</h2>

<p>This is the actual test I wrote and what the code looks like now.
I have been working on separating things out into Commands and Queries.
This was a Command I had to fix.</p>

<p>So, as always, I started off with a test. I still do Arrange-Act-Assert
as a way to organize the test. I thought about dependencies, like
a Request object and a Response object.</p>

<pre><code class="php">        $req = $this-&gt;createMock(Request::class);
        $req-&gt;expects($this-&gt;once())
            -&gt;method('getParsedBody')
            -&gt;willReturn([
                'week' =&gt; 99,
                'franchise_id' =&gt; [1],
                'rotation' =&gt; ['Moe, Larry, Curly'],
                'current_rotation' =&gt; [''],
                'rotation_id' =&gt; [0],
            ]
        );

        $response = $this-&gt;createMock(Response::class);
        $response-&gt;expects($this-&gt;any())-&gt;method('withStatus')-&gt;will($this-&gt;returnSelf());
        $response-&gt;expects($this-&gt;any())-&gt;method('withHeader')-&gt;will($this-&gt;returnSelf());
</code></pre>

<p>I also needed to make sure the database would work inside my test
environment. I just cut-and-paste code from a bootstrapping section
elsewhere in the application. Next time I write a test that needs
to use the database, I will extract this code into a helper.</p>

<pre><code class="php">        $container = new Container(require __DIR__ . '/../../config/settings.php');
        $container-&gt;set(EntityManager::class, static function (Container $c): EntityManager {
            $settings = $c-&gt;get('settings');

            $cache = $settings['doctrine']['dev_mode'] ?
                new ArrayAdapter() :
                new FilesystemAdapter(directory: $settings['doctrine']['cache_dir']);

            $config = ORMSetup::createAttributeMetadataConfiguration(
                $settings['doctrine']['metadata_dirs'],
                $settings['doctrine']['dev_mode'],
                null,
                $cache
            );

            return EntityManager::create($settings['doctrine']['connection'], $config);
        });

</code></pre>

<p>Because the application uses a dependency injection container, I also needed to
make sure my repository object I needed in the code would be available.</p>

<pre><code class="php">        $container-&gt;set(RotationRepository::class, function (Container $c): RotationRepository {
            return new RotationRepositoryUsingDoctrine($c-&gt;get(EntityManager::class));
        });


        /** @var RotationRepositoryUsingDoctrine $repo */
        $repo = $container-&gt;get(RotationRepository::class);
</code></pre>

<p>With those all set, the test becomes:</p>

<ul>
<li>Given I have an existing rotation</li>
<li>When I update that rotation</li>
<li>I should only see that updated rotation in the database</li>
</ul>

<pre><code class="php">        $command = new UpdateRotationsCommand($repo);
        $command-&gt;__invoke($req, $response);

        $rotation = $repo-&gt;getByWeekAndFranchiseId(99, 1);

        $req = $this-&gt;createMock(Request::class);
        $req-&gt;expects($this-&gt;once())
            -&gt;method('getParsedBody')
            -&gt;willReturn([
                'week' =&gt; 99,
                'franchise_id' =&gt; [1],
                'rotation' =&gt; ['Moe, Larry, Curly Joe'],
                'rotation_id' =&gt; [$rotation-&gt;getId()],
                'current_rotation' =&gt; ['Moe, Larry, Curly'],
            ]
        );
        $command = new UpdateRotationsCommand($container-&gt;get(RotationRepository::class));
        $command-&gt;__invoke($req, $response);

        $rotation = $repo-&gt;getByWeekAndFranchiseId(99, 1);

        $this-&gt;assertEquals('Moe, Larry, Curly Joe', $rotation-&gt;getRotation());
</code></pre>

<p>This test took me a bit of work to get exactly right, but I didn't go an write
any additional code just quite yet. I needed to:</p>

<ul>
<li>update the <code>UpdateRotationsCommand</code></li>
<li>add a new <code>getByWeekAndFranchiseId</code> method to my rotations repository object</li>
</ul>

<pre><code class="php">final class UpdateRotationsCommand
{
    public function __construct(private RotationRepository $repo) {}

    public function __invoke(Request $req, Response $response): Response 
    {
        $params = $req-&gt;getParsedBody();
        $week = (int) $params['week'];

        $franchiseIds = $params['franchise_id'];
        $rotations = $params['rotation'];
        $rotationIds = $params['rotation_id'] ?? [];
        $currentRotations = $params['current_rotation'];

        foreach ($franchiseIds as $idx =&gt; $franchiseId) {
            if ($rotations[$idx] !== $currentRotations[$idx]) {

                if (isset($rotationIds[$idx]) &amp;&amp; (int)$rotationIds[$idx] !== 0) {
                    $rotation = $this-&gt;repo-&gt;getById((int)$rotationIds[$idx]);
                    $rotation-&gt;setId((int)$rotationIds[$idx]);
                } else {
                    $rotation = new Rotation();
                }

                $rotation-&gt;setWeek($week);
                $rotation-&gt;setRotation($rotations[$idx]);
                $rotation-&gt;setFranchiseId((int) $franchiseId);
                $this-&gt;repo-&gt;save($rotation);
            }
        }

        return $response
            -&gt;withHeader('Location', '/rotation_management?week=' . $week)
            -&gt;withStatus(302);
    }
}
</code></pre>

<p>I remain convinced I can improve that code in the <code>foreach</code> but my goal is
always to make sure the bug no longer exists and then, if I want, go back
and make it "nicer".</p>

<pre><code class="php">    public function getByWeekAndFranchiseId(int $week, int $franchiseId): Rotation 
    {
        return $this-&gt;em
            -&gt;getRepository(Rotation::class)
            -&gt;findOneBy(['week' =&gt; $week, 'franchiseId' =&gt; $franchiseId]);
    }
</code></pre>

<p>So now I have an automated test that verifies that the bug was reported
no longer exists. Are there any new bugs lurking? No idea. Only three people
use this application so there are a whole series of tests I probably will
never have to write.</p>

<p>Here is the complete test:</p>

<pre><code class="php">declare(strict_types=1);

use Symfony\Component\Cache\Adapter\ArrayAdapter;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\ORMSetup;
use PHPUnit\Framework\TestCase;
use Slim\Psr7\Request;
use Slim\Psr7\Response;
use Symfony\Component\Cache\Adapter\FilesystemAdapter;
use UMA\DIC\Container;
use Webreg\Command\UpdateRotationsCommand;
use Webreg\Repository\RotationRepository;
use Webreg\Repository\RotationRepositoryUsingDoctrine;

final class UpdateRotationsCommandTest extends TestCase
{
    /**
     * @test
     */
    public function itUpdatesExistingRecordsCorrectly(): void
    {
        $req = $this-&gt;createMock(Request::class);
        $req-&gt;expects($this-&gt;once())
            -&gt;method('getParsedBody')
            -&gt;willReturn([
                'week' =&gt; 99,
                'franchise_id' =&gt; [1],
                'rotation' =&gt; ['Moe, Larry, Curly'],
                'current_rotation' =&gt; [''],
                'rotation_id' =&gt; [0],
            ]
        );

        $response = $this-&gt;createMock(Response::class);
        $response-&gt;expects($this-&gt;any())-&gt;method('withStatus')-&gt;will($this-&gt;returnSelf());
        $response-&gt;expects($this-&gt;any())-&gt;method('withHeader')-&gt;will($this-&gt;returnSelf());

        $container = new Container(require __DIR__ . '/../../config/settings.php');
        $container-&gt;set(EntityManager::class, static function (Container $c): EntityManager {
            $settings = $c-&gt;get('settings');

            $cache = $settings['doctrine']['dev_mode'] ?
                new ArrayAdapter() :
                new FilesystemAdapter(directory: $settings['doctrine']['cache_dir']);

            $config = ORMSetup::createAttributeMetadataConfiguration(
                $settings['doctrine']['metadata_dirs'],
                $settings['doctrine']['dev_mode'],
                null,
                $cache
            );

            return EntityManager::create($settings['doctrine']['connection'], $config);
        });

        $container-&gt;set(RotationRepository::class, function (Container $c): RotationRepository {
            return new RotationRepositoryUsingDoctrine($c-&gt;get(EntityManager::class));
        });


        /** @var RotationRepositoryUsingDoctrine $repo */
        $repo = $container-&gt;get(RotationRepository::class);

        $command = new UpdateRotationsCommand($repo);
        $command-&gt;__invoke($req, $response);

        $rotation = $repo-&gt;getByWeekAndFranchiseId(99, 1);

        $req = $this-&gt;createMock(Request::class);
        $req-&gt;expects($this-&gt;once())
            -&gt;method('getParsedBody')
            -&gt;willReturn([
                'week' =&gt; 99,
                'franchise_id' =&gt; [1],
                'rotation' =&gt; ['Moe, Larry, Curly Joe'],
                'rotation_id' =&gt; [$rotation-&gt;getId()],
                'current_rotation' =&gt; ['Moe, Larry, Curly'],
            ]
        );
        $command = new UpdateRotationsCommand($container-&gt;get(RotationRepository::class));
        $command-&gt;__invoke($req, $response);

        $rotation = $repo-&gt;getByWeekAndFranchiseId(99, 1);

        $this-&gt;assertEquals('Moe, Larry, Curly Joe', $rotation-&gt;getRotation());
    }
}
</code></pre>

<p>So now I know that manually testing things is the last option to verify
behaviour, not my only option.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[NeoVim and Xdebug]]></title>
            <link href="https://grumpy-learning.com/blog/2023/04/03/neovim-and-xdebug/"/>
            <updated>2023-04-03T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/04/03/neovim-and-xdebug/</id>
            <content type="html"><![CDATA[<h1 id="neovim-and-xdebug">NeoVim and Xdebug</h1>

<p>As I continue to work on the configuration for the <a href="https://neovim.io">One True Editor</a>
I had everything working just about the way that duplicated how I use <a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a>
except for one thing -- using <a href="https://xdebug.org">Xdebug</a>.</p>

<p>As I write this blog post I have an article submitted for <a href="https://www.phparch.com">php[architect]</a>
on how I use NeoVim to do PHP development work and in that article
I talked about the next few things I was going to work on adding
support for ($100 a year to do enemy research on Copilot AI?!?)
and getting the tool that I regret not embracing earlier but
now find it indispensable.</p>

<p>This is not the blog post if you are looking to figure out
how to get Xdebug running with whatever version of PHP you
are trying to use. The excellent documentation on the Xdebug
web site will absolutely point you in the right direction.</p>

<p>In my case, I went the route of manually compiling the 3.2.x
series (I honestly cannot remember why) but most package
managers for your operating system of choice can help you
with that.</p>

<h2 id="xdebug-and-dap">Xdebug and DAP</h2>

<p>DAP (which is short for the <a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Anywhere Protocol</a>.
Look, you can quibble about who is behind DAP but the overarching
goal of providing a standardized way for both debugging tools
and programming languages to talk to each other makes a lot
of sense. The <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>
is a similar effort that has found a lot of traction outside
of Microsoft.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>You to have the following before we get started:</p>

<ul>
<li>a version of PHP with Xdebug support</li>
<li>NeoVim 0.5+ or better</li>
<li>the ability to edit your NeoVim configuration files</li>
<li>the ability to install NeoVim plugins</li>
<li>Node installed (need it to install some tooling)</li>
<li>Git CLI tools installed</li>
</ul>

<h2 id="debug-adapter-for-php">Debug Adapter for PHP</h2>

<p>To start, I followed the excellent instructions found <a href="https://github.com/mfussenegger/nvim-dap/wiki/Debug-Adapter-installation#PHP">here</a>
but to replicate them here:</p>

<pre><code class="bash">git clone https://github.com/xdebug/vscode-php-debug.git
cd vscode-php-debug
npm install &amp;&amp; npm run build
</code></pre>

<p>Leveraging an existing tool to make it work is always galaxy-brain-level
thinking.</p>

<p>Next, I decided on which plugins I wanted to use to interact
with Xdebug while inside NeoVim. I chose:</p>

<ul>
<li><a href="https://github.com/mfussenegger/nvim-dap">mfussenegger/nvim-dap</a> for high-level support</li>
<li><a href="https://github.com/rcarriga/nvim-dap-ui">rcarriga/nvim-dap-ui</a> as my UI for looking at the debug details</li>
<li><a href="https://github.com/theHamsta/nvim-dap-virtual-text">theHamsta/nvim-dap-virtual-text</a> find variable definitions</li>
<li><a href="https://github.com/nvim-telescope/telescope-dap.nvim">nvim-telescope/telescope-dap.nvim</a> to provide compatibility with Telescope</li>
</ul>

<p>Again, I encourage people to start with a base that WORKS and
then start experimenting to get it the way you want it.</p>

<h2 id="dap-plugin-configuration">DAP Plugin Configuration</h2>

<p>Again, this is for my own setup. It might be different for your
own.</p>

<p>I needed to make sure that I turn on Telescope support in my
<code>init.vim</code> file. I need it for other plugins but make sure
you enable it if you are using <code>telescope-dap.nvim</code>.</p>

<pre><code class="bash">lua require('telescope').setup
</code></pre>

<p>Note that the above is how to load <a href="https://www.lua.org">Lua</a> files
inside a <a href="https://devhints.io/vimscript">Vimscript</a> file. I am starting
to work on the outline of using Lua for all my NeoVim configuration
settings.</p>

<p>Next, I have a configuration file just for DAP that I also load in
my <code>init.vim</code> file:</p>

<pre><code class="lua">local dap = require('dap')
require('telescope').load_extension('dap')

dap.adapters.php = {
    type = "executable",
    command = "node",
    args = { os.getenv("HOME") .. "/vscode-php-debug/out/phpDebug.js" }
}

dap.configurations.php = {
    {
        type = "php",
        request = "launch",
        name = "Listen for Xdebug",
        port = 9003
    }
}
</code></pre>

<p>In here I tell NeoVim:</p>

<ul>
<li>load the DAP extension for Telescope (it overrides the default UI)</li>
<li>I want to use the VS Code DAP adapter</li>
<li>what port to listen for Xdebug info on (Xdebug 3.2.x goes with 9003 as the standard port)</li>
</ul>

<p>On the Xdebug web site section <a href="https://github.com/xdebug/vscode-php-debug#supported-launchjson-settings">about VS Code</a>
it points out that you can also add in a <code>pathMappings</code>
value in <code>dap.configurations.php</code> to "map the files on the server to
the right files on your local machine." and gives an example.</p>

<p>I don't use <code>pathMappings</code> and my setup works just fine.</p>

<p>Of course, I could not really use Xdebug from inside the editor without
some keyboard mappings:</p>

<pre><code class="lua">vim.keymap.set('n', '&lt;F5&gt;', function() require('dap').continue() end)
vim.keymap.set('n', '&lt;F10&gt;', function() require('dap').step_over() end)
vim.keymap.set('n', '&lt;F11&gt;', function() require('dap').step_into() end)
vim.keymap.set('n', '&lt;F12&gt;', function() require('dap').step_out() end)
vim.keymap.set('n', '&lt;Leader&gt;b', function() require('dap').toggle_breakpoint() end)
vim.keymap.set('n', '&lt;Leader&gt;B', function() require('dap').set_breakpoint() end)
vim.keymap.set('n', '&lt;Leader&gt;lp', function() require('dap').set_breakpoint(nil, nil, vim.fn.input('Log point message: ')) end)
vim.keymap.set('n', '&lt;Leader&gt;dr', function() require('dap').repl.open() end)
vim.keymap.set('n', '&lt;Leader&gt;dl', function() require('dap').run_last() end)
vim.keymap.set({'n', 'v'}, '&lt;Leader&gt;dh', function()
  require('dap.ui.widgets').hover()
end)
vim.keymap.set({'n', 'v'}, '&lt;Leader&gt;dp', function()
  require('dap.ui.widgets').preview()
end)
vim.keymap.set('n', '&lt;Leader&gt;df', function()
  local widgets = require('dap.ui.widgets')
  widgets.centered_float(widgets.frames)
end)
vim.keymap.set('n', '&lt;Leader&gt;ds', function()
  local widgets = require('dap.ui.widgets')
  widgets.centered_float(widgets.scopes)
end)
</code></pre>

<p>My usual workflow for debugging is:</p>

<ul>
<li>code I am debugging open in the editor</li>
<li>if I didn't already start debugging, hit <code>F5</code> to turn on the debugging session</li>
<li>set breakpoints where I want them with <code>\b</code></li>
<li>run the code, step through the breakpoints, and see what's going on</li>
</ul>

<p>Not different in any significant way than how I would do things in PhpStorm.</p>

<p>So there you have it! If you are a NeoVim user and want to
start utilizing Xdebug to help you, well, debug your code
faster my documentation above should get you pointed in
the correct direction.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Thinking About Testing Too Much]]></title>
            <link href="https://grumpy-learning.com/blog/2023/03/09/thinking-about-it-too-much/"/>
            <updated>2023-03-09T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2023/03/09/thinking-about-it-too-much/</id>
            <content type="html"><![CDATA[<h1 id="thinking-about-testing-too-much">Thinking About Testing Too Much</h1>

<p>Back in February and had a <a href="https://www.freethegeek.fm/51">very long and fun chat</a> with
my friend Matt Setter about the one topic I think about way too much -- testing. Rather
than steal what Matt wrote, just go read the linked above post to get a sense of what
we discussed. If you have followed my rantings online for any period of time, none of
what I discussed there should be new to you.</p>

<p>I mean, you can't really blame me -- my career niche has been "testing PHP code" since at
least 2006. That is a really, really long time to be focussed on an issue. Now, I might
not be the best programmer (a lot of times I feel like I have been doing programming for
1 year, 25 times) but I do know a ton about what does and does not lead to good outcomes
for long-running projects.</p>

<h2 id="the-next-wave-of-testing">The Next Wave Of Testing</h2>

<p>As I write this, I am at a crossroads as to what to talk about next. I'm kind of over speaking
at conferences except in places I have not been (if you are an organizer of an event in Africa,
South America, or Japan -- please get in touch) and I am not sure I want to put the effort
in to write yet another book or do training courses. If I am being honest, I am getting older
and like hanging out at home more and having unstructured time. I have two frustrating hobbies
that can keep my mind sharp. Arguing with people about testing their code feels like a losing
proposition and a huge waste of my time.</p>

<p>So, what I have found interesting is the increasingly-growing idea that there are some code-related
things that you can do that can reduce the amount of tests you need to write for your code
or sometimes even eliminate them. This is, of course, at best misguided and at worst, wrong.</p>

<h2 id="types-as-tests">Types As Tests</h2>

<p>When they got introduced into the language, I viewed typing (I define it as declaring at creation
what 'type' of thing an object or variable is supposed to be) as something that would get rid
of some types of tests I found myself writing and allow the PHP interpreter to enforce rules
about what sort of things my code was returning to other code that called it. No more tests
verifying that a method returned an array!</p>

<p>They are NOT a substitute for tests. They are a helpful tool that provides intent for your code
and greatly reduces the likelihood of SOME types of errors happening when (for example) your
code is expecting a list of things and instead gets a string.</p>

<h2 id="static-analysis-as-tests">Static Analysis As Tests</h2>

<p>Static analysis tools are something I have been using professionally for a few years. They are
an additional layer ON TOP OF types that goes even further down the road of making sure the intent
of your code is clear. Sure, it's annoying to have a tool say "well, actually, you said over HERE
that you are expecting an array but you ACTUALLY are passing a list. What one is it?" but it's
better than you trying to figure out why some code you wrote yesterday suddenly stopped working
today when you (and this is often not reality) "didn't change anything".</p>

<p>Again, these are NOT a substitute for tests. They are a COMPLEMENTARY tool for testing. Just because
PHPStan is not reporting any errors doesn't mean your code is behaving as expected!</p>

<h2 id="grumpy%27s-theory-on-tests">Grumpy's Theory On Tests</h2>

<p>I am incredibly confident in saying that you should 100% have automated tests for your application
that cover:</p>

<ul>
<li>business logic</li>
<li>how your users will interact with your app</li>
</ul>

<p>What testing tools you use to make this happens is up to you. If you have done a decent job of
creating a decoupled code base where you are injecting dependencies to your objects (let's be
real, 90% of PHP code out there still running and accessible online is object oriented) then
you should be able to write unit tests where you create the dependencies the code you are testing
needs.</p>

<p>They can be the real thing (which I prefer) or doubles (don't be scared, you probably waste more
time on social media than it would take to keep the doubles in sync as you work on the code base)
but you MUST have the ability to modify these dependencies at run time.</p>

<p>If you also write your code in a more defensive style -- think filtering input, escaping output,
validating things, using immutability -- your tests become easier
to create and the testing scenarios you create become easier and easier to define and implement.</p>

<p>You need tests. Your code should be easy to test. I'm not mad at you if your code isn't in a place
where it easy to test. There are ways  to make them testable. No, I am
not talking about end-to-end tests with browser automation. Those are brittle and I have seen too
many of those types of test suites with weird custom helpers and step definitions that do not
reflect how the application works AT ALL. Don't do that. Browser automation is a last, desperate
test in my opinion.</p>

<p>Write assertion-based tests using real dependencies as much as possible. I'm happy to help you
get there. It will cost some time and some money but it will make the cost of the NEXT change so
much easier.</p>

<p>Hope you enjoyed the results of thinking too much about this stuff. There is SO much more I want
to learn in order to make your testing tasks easier.</p>
]]></content>
        </entry>
    </feed>