<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Grumpy Learning]]></title>
    <link href="https://grumpy-learning.com/atom.xml" rel="self"/>
    <link href="https://grumpy-learning.com/"/>
    <updated>2022-12-09T23:36:46+00:00</updated>
    <id>https://grumpy-learning.com/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Testing decoupled PHP code?]]></title>
            <link href="https://grumpy-learning.com/blog/2022/12/06/testing-decoupled-code/"/>
            <updated>2022-12-06T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/12/06/testing-decoupled-code/</id>
            <content type="html"><![CDATA[<p>One of the reasons many experienced developers encourage the concept of
"decoupling your code" is so that it makes testing your code straightforward.
I wanted to share an example of how I went about writing some tests for
some code that I had refactored from being a tangled spaghetti-like mess.</p>

<p>Here is the code I am looking at, written targeting PHP 8.1.</p>

<pre><code class="php">&lt;?php
declare(strict_types=1);

namespace Webreg\Query;

use Slim\Psr7\Response;
use Slim\Psr7\Request;
use Twig\Environment;
use Webreg\Repository\GameRepository;
use Webreg\ViewModel\Rotations;

final class RotationManagementQuery
{
    public function __construct(
        private Environment $twig,
        private GameRepository $gameRepository,
        private Rotations $rotations
    ) {}

    public function __invoke(Request $request): Response
    {
        $params = $request-&gt;getQueryParams();
        $maxWeek = $this-&gt;gameRepository-&gt;getMaxWeek();
        $week = (isset($params['week'])) ? (int) $params['week'] : $maxWeek;
        $rotations = $this-&gt;rotations-&gt;getAllByWeek($week);
        $response = new Response(200, null);
        $response-&gt;getBody()-&gt;write($this-&gt;twig-&gt;render('rotations/management.twig', [
            'current_week' =&gt; $week,
            'rotations' =&gt; $rotations,
        ]));

        return $response;
    }
}
</code></pre>

<p>I am using <a href="https://www.martinfowler.com/bliki/CQRS.html">Command Query Responsibility Segregation</a> in
this application's architecture, and this bit of code is a Query that will
retrieve a collection of pitchers who will be starting for baseball
teams in my simulation baseball league for a particular week.</p>

<p>In following some rules for decoupling, you can see some of the
following decisions had been made:</p>

<ul>
<li>not extending off of a base class</li>
<li>all dependencies are injected at run time</li>
<li>single-method for the class</li>
</ul>

<h2 id="identifying-dependencies">Identifying Dependencies</h2>

<p>So what are the dependencies I will need?</p>

<ul>
<li>a <a href="https://twig.symfony.com">Twig</a> object</li>
<li>a <a href="https://martinfowler.com/eaaCatalog/repository.html">repository</a> object for retrieving data</li>
<li>a <a href="https://martinfowler.com/eaaDev/PresentationModel.html">view model</a> for presenting the data</li>
<li>an object that contains the HTTP <a href="https://www.php-fig.org/psr/psr-7/">request</a></li>
</ul>

<p>In the old architecture, I was creating those dependencies deep inside the "business logic"
and therefore it was very hard to write anything other than some kind of "check
the HTML output" type of test. Ironically that is what the new test does as well but
this sort of decoupled architecture leads to a much more straightforward test.</p>

<h2 id="identifying-output">Identifying Output</h2>

<p>In these tests, I wanted to make sure that if I had at least one rotation
stored in the database for a particular week, when the page renders I should
see that rotation in the output somewhere.</p>

<h2 id="test-skeleton">Test Skeleton</h2>

<p>As always, I break out the <a href="http://wiki.c2.com/?ArrangeActAssert">Arrange-Act-Assert</a> pattern
to create the skeleton of the test:</p>

<pre><code class="php">    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange

        // Act

        // Assert
        self::fail();
    }
</code></pre>

<p>Remember, you always want to start with a failing test.</p>

<h2 id="arranging-our-dependencies">Arranging our dependencies</h2>

<p>These days I try and use the fewest number of <a href="https://phpunit.readthedocs.io/en/9.5/test-doubles.html">test doubles</a>
in my test scenarios. Given the dependencies I needed,
I was going to need three "fake" dependencies, configured
to provide only the implementation details required to make
the scenario work.</p>

<p>I don't want to get into a longer discussion on the use of
test doubles except to say that the decoupling strategy
I am using will minimize the chances that any doubles drift
from how the code is actually implemented.</p>

<p>Trust me, I do this for a living!</p>

<pre><code class="php">    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange
        $loader = new FilesystemLoader(__DIR__ . '/../../templates/');
        $twig = new Environment($loader);

        $gamesRepo = $this-&gt;createMock(GameRepository::class);
        $gamesRepo-&gt;expects($this-&gt;once())
            -&gt;method('getMaxWeek')
            -&gt;willReturn(1);

        $testRotation = new ArrayCollection();
        $testRotation-&gt;add([
            'franchise_id' =&gt; 1,
            'ibl' =&gt; 'MAD',
            'rotation' =&gt; 'One, Two, Three'
        ]);

        $viewModel = $this-&gt;createMock(RotationsUsingDoctrine::class);
        $viewModel-&gt;expects($this-&gt;once())
            -&gt;method('getAllByWeek')
            -&gt;willReturn($testRotation);

        $request = $this-&gt;createMock(Request::class);
        $request-&gt;expects($this-&gt;once())
            -&gt;method('getQueryParams')
            -&gt;willReturn(['week' =&gt; 1]);

        // Act

        // Assert
        self::fail();
    }
</code></pre>

<h2 id="acting-on-the-code-under-test">Acting on the code-under-test</h2>

<p>This has always struck me as a weird way to describe "executing the
code we are testing" but I guess "Arrange-Execute-Assert" doesn't
flow in English quite the same way.</p>

<p>Now that I have all my dependencies created and configured the way
I need, time to run the code and grab some results I can test.</p>

<pre><code class="php">    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange

        // Act
        $query = new RotationManagementQuery($twig, $gamesRepo, $viewModel);
        $results = $query-&gt;__invoke($request);

        // Assert
        self::fail();
    }
</code></pre>

<h2 id="asserting-results-of-code-execution">Asserting results of code execution</h2>

<p>Just like I did before, I am checking the HTML output from executing
this Query to make sure I am seeing values that I expect</p>

<pre><code class="php">    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange

        // Act

        // Assert
        self::assertStringContainsString('One, Two, Three', $results-&gt;getBody());
    }
</code></pre>

<p>When building my assertions, I tend to go with "what are the
fewest number of things I need to do in order to prove the
code is working as expected."</p>

<p>In this case, I felt checking that I see an expected "pitching rotation"
in the output is good enough.</p>

<p>Here is what the whole test looks like:</p>

<pre><code class="php">&lt;?php

namespace Webreg\Test\Query;

use Doctrine\Common\Collections\ArrayCollection;
use Slim\Psr7\Request;
use Twig\Environment;
use Twig\Loader\FilesystemLoader;
use Webreg\Query\RotationManagementQuery;
use PHPUnit\Framework\TestCase;
use Webreg\Repository\GameRepository;
use Webreg\ViewModel\RotationsUsingDoctrine;

class RotationManagementQueryTest extends TestCase
{
    /** @test */
    public function it_returns_expected_rotation(): void
    {
        // Arrange
        $loader = new FilesystemLoader(__DIR__ . '/../../templates/');
        $twig = new Environment($loader);

        $gamesRepo = $this-&gt;createMock(GameRepository::class);
        $gamesRepo-&gt;expects($this-&gt;once())
            -&gt;method('getMaxWeek')
            -&gt;willReturn(1);

        $testRotation = new ArrayCollection();
        $testRotation-&gt;add([
            'franchise_id' =&gt; 1,
            'ibl' =&gt; 'MAD',
            'rotation' =&gt; 'One, Two, Three'
        ]);

        $viewModel = $this-&gt;createMock(RotationsUsingDoctrine::class);
        $viewModel-&gt;expects($this-&gt;once())
            -&gt;method('getAllByWeek')
            -&gt;willReturn($testRotation);

        $request = $this-&gt;createMock(Request::class);
        $request-&gt;expects($this-&gt;once())
            -&gt;method('getQueryParams')
            -&gt;willReturn(['week' =&gt; 1]);

        // Act
        $query = new RotationManagementQuery($twig, $gamesRepo, $viewModel);
        $results = $query-&gt;__invoke($request);

        // Assert
        self::assertStringContainsString('One, Two, Three', $results-&gt;getBody());
    }
}

</code></pre>

<p>Some thoughts that occur to me from looking at the final test:</p>

<ul>
<li>decoupling makes your dependencies quite visible during test creation</li>
<li>always make sure to only implement the behaviour of your test doubles that you need</li>
<li>your Arrange step will almost always be the largest part of any test</li>
<li>PHPUnit's built-in test double generators also act as assertions</li>
<li>sometimes the simplest way of verifying behaviour is what you should use</li>
</ul>

<p>From my perspective, decoupling the code allows me to focus on smaller
pieces of application behaviour, reducing the chances that a change in
this code breaks something somewhere else.</p>

<p>For more details on the approach I am using for decoupling my code, check
out Matthias Noback's <a href="https://leanpub.com/recipes-for-decoupling">"Recipes for Decoupling"</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Why isn&#039;t testing ubiquitous?]]></title>
            <link href="https://grumpy-learning.com/blog/2022/11/22/why-isnt-testing-ubiquitous/"/>
            <updated>2022-11-22T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/11/22/why-isnt-testing-ubiquitous/</id>
            <content type="html"><![CDATA[<p>Over on Twitter Mathias Verraes tweeted something that immediately 
triggered some feelings:</p>

<blockquote>
  <blockquote>
    <p>Perhaps TDD isn't as ubiquitous as it should be because you
    can't make a business model out of it.
    (Original post on Twitter <a href="https://twitter.com/mathiasverraes/status/1595100145129263106">https://twitter.com/mathiasverraes/status/1595100145129263106</a></p>
  </blockquote>
</blockquote>

<p>I commented saying "Boy do I ever have feelings about this topic..." and
Matias asked me to share. I decided my response was better off as
a longer blog post. Don't worry, this will end up on Twitter / Mastodon
anyway.</p>

<p>He mentioned "observability" as a technique that ended up
being a very good business model. Why? In my opinion, figuring out
how to observe something in production is generic enough in that you
can create a tool and say "hey, add these stuff to your code or
production systems, and it will report stuff to this well-crafted
dashboard you can use to get an idea of what is going on."</p>

<p>I am a fan of these approach -- I highly recommend looking into
things like <a href="https://www.honeycomb.io">Honeycomb</a> to get an idea
of what you are signing up for when you choose that path.</p>

<p>So what about testing? Is testing generic enough that you could come
up with some kind of black box or external system that you can connect
your tests to and react to when things fail?</p>

<p>Tests are almost entirely bespoke. Dependent on architecture. Dependent
on environments. Heck, dependant on the skill of the people who have to
write and maintain them.</p>

<p>Also, in my experience, tests work best when you approach them from
the idea that they are there to make sure things are behaving as you
expect them to and to give you a way to determine if you've made changes
that have broken something elsewhere in your application.</p>

<p>In other words, chances are that a failing test is something that the
users of your application will never notice. They will notice broken
pages, non-functioning links, slow-to-respond interfaces. Those are things
that can probably be monitored through observability tools.</p>

<p>In a lot of cases you start off with the idea of having to add tests to
a system being adversarial. Developers don't want to spend the time
writing them. Management views them as tasks with little-to-no return
on investments. Clients balk at being told your bid is more expensive because
you are writing tests. Flaky tests reduce confidence. Build tools need
to be able to play nicely with your chosen testing tools. Effective
test suites can take a lot of time to create and maintain.</p>

<p>Not to mention almost nobody teaches people how to learn to use a programming
language from a test-centric perspective. I could not even imagine
how to teach a novice programmer how to use PHP while also showing them
how to use all the tools. Understanding my own target audience is developers-with-experience
has really changed how I teach and what I teach them.</p>

<p>Using an observability tool
can often be as simple as signing up for an online tool, follow their
directions on what needs to happen to monitor things, and then you
will know a lot faster when things aren't behaving correctly in
production.</p>

<p>Under those types of terms, testing will never be ubiquitous. Which
is a shame because it is a technique that can lead to stable code
bases and confident deployments to production.</p>

<p>Maybe someone out there with a different perspective will figure out
how to solve the stuff I talked about here. Until then, I am still happy
to help teach people how to add automated testing to their skill set
and hope they find it as useful as I have.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[A Grumpy POSSE]]></title>
            <link href="https://grumpy-learning.com/blog/2022/11/18/a-grumpy-posse/"/>
            <updated>2022-11-18T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/11/18/a-grumpy-posse/</id>
            <content type="html"><![CDATA[<p>One of the main reasons I have decided to embrace more of
the <a href="https://indieweb.org">IndieWeb</a> ethos is out of a desire
to have more control over where the various things I create
(micro-blogging and longer-form content) ends up. Twitter ended
up being something that replaced the blogging I used to do.</p>

<p>One of the concepts coming out of the Indieweb is the great-sounding
acronym POSSE. It stands for Publish On your own Site, Syndicate Elsewhere.
Which is another way of saying you should have one central location
where most of your material lives (shitposting on social media still will
happen) and then push that content out to other places.</p>

<p>So for me, what would this look like?</p>

<p>For a long time I had another blog, but once I really leaned into the
Grumpy Programmer brand that blog served no purpose and I really should've
just moved stuff over there. Although that old blog is no longer online
I still have all the posts I made to it. Maybe I will go through one day
and do "the best of when I was less grumpy" or something like that.</p>

<p>So, in a world where I embrace POSSE, here is how it should work:</p>

<ul>
<li>I write content on this blog</li>
<li>I use the static site generator <a href="https://sculpin.io">Sculpin</a> to create the site</li>
<li>As part of updating my site, I then automatically publish a link to that blog elsewhere</li>
</ul>

<p>There are other solutions to make this happen if you use other blogging
engines (static or otherwise) but there was nothing out-of-the-box to make it
work for Sculpin. So, I used my <a href="https://duckduckgo.com">favourite search engine</a>
and started doing some research.</p>

<p>I also, like any good online influencer, leveraged my personal relationships
with people...like the current maintainer of Sculpin...to ask them how I could accomplish
a few tasks.</p>

<h2 id="writing-on-this-blog">Writing on this blog</h2>

<p>Sculpin supports me writing posts using Markdown. This means I get to keep using
the <a href="https://neovim.io">new One True Editor</a> to create new posts. It also uses
<a href="https://twig.symfony.com">Twig</a> for the templates it uses to generate the static
HTML for the site.</p>

<p>Again, I am not telling you one way or the other what to use for your blog. For a lot
of folks using <a href="https://wordpress.com">Wordpress</a> and a plugin tailored to IndieWeb
needs will work. I didn't want to setup anything new, so I was going to stick with
Sculpin.</p>

<h2 id="creating-the-site">Creating the site</h2>

<p>I am currently using GitHub pages for this site, so all I have to do is copy the
generated HTML output into the correct location in the repo that holds my site,
push those changes up to GitHub and in a minute or two I have a new version of
my web site for all the world to see.</p>

<p>This is no big change for what I was doing previously -- I used to have an AWS
Lightsail instance for hosting the blog but decided GitHub was a better option
since I was already paying for an account there. Why pay twice?!?</p>

<p>Now, to prepare my site to be "IndieWeb friendly" is simply followed the instructions
at <a href="https://indiewebify.me">IndeWebify.me</a>. Followed by, of course, a lot of
commits and pushes to get things to behave exactly the way I needed them to.</p>

<p>For example. this is what the template looks like for a blog post, with all the
IndieWeb <a href="https://microformats.org/">microformats</a> embedded in them:</p>

<pre><code>
{% extends "default" %}

{% block head_meta %}
    &lt;meta name="robots" content="index, follow"&gt;
{% endblock %}

{% block content_wrapper %}
    &lt;article class="h-entry"&gt;
        &lt;header&gt;
            &lt;h2&gt;&lt;div class="p-name"&gt;{{ page.title }}&lt;/div&gt; &lt;small&gt;post&lt;/small&gt;&lt;/h2&gt;
        &lt;/header&gt;
        &lt;div class="e-content"&gt;
            {{ page.blocks.content|raw }}
        &lt;/div&gt;
        {% if page.categories %}
            &lt;p class="categories"&gt;
            Categories:
            {% for category in page.categories %}
            &lt;a class="p-category" href="{{ site.url }}/blog/categories/{{ category|url_encode(true) }}"&gt;{{ category }}&lt;/a&gt;{% if not loop.last %}, {% endif %}
            {% endfor %}
            &lt;/p&gt;
        {% endif %}
        {% if page.tags %}
            &lt;p class="tags"&gt;
            Tags:
            {% for tag in page.tags %}
            &lt;a href="{{ site.url }}/blog/tags/{{ tag|url_encode(true) }}"&gt;{{ tag }}&lt;/a&gt;{% if not loop.last %}, {% endif %}
            {% endfor %}
            &lt;/p&gt;
        {% endif %}
        &lt;a href="https://brid.gy/publish/mastodon"&lt;/a&gt;
        &lt;a href="https://brid.gy/publish/twitter"&lt;/a&gt;
        {% if page.previous_post or page.next_post %}
            &lt;nav class="article"&gt;
                &lt;ul&gt;
                    {% if page.next_post %}
                        &lt;li&gt;Next: &lt;a class="next" href="{{ site.url }}{{ page.next_post.url }}" title="{{ page.next_post.title }}"&gt;&lt;span class="title"&gt;{{ page.next_post.title }}&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
                    {% endif %}
                    {% if page.previous_post %}
                        &lt;li&gt;Previous: &lt;a class="previous" href="{{ site.url }}{{ page.previous_post.url }}" title="{{ page.previous_post.title }}"&gt;&lt;span class="title"&gt;{{ page.previous_post.title }}&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
                    {% endif %}
                &lt;/ul&gt;
            &lt;/nav&gt;
        {% endif %}
    &lt;/article&gt;
{% endblock %}

</code></pre>

<h2 id="the-grumpy-posse">The Grumpy POSSE</h2>

<p>Figuring out how to syndicate my content without an existing plugin proved to
be a bit of a challenge. Luckily, I found a blog post that explained how to
make this work by embracing <a href="https://indieweb.org/Webmention">Webmentions</a>
and using an awesome (and free!) service called <a href="https://brid.gy">Bridgy</a>
to automate syndication.</p>

<p>The solution I found was to create a GitHub action that would be triggered
each time I did a push to the repo. This action would take care of using
webmentions and Brid.gy to do the magic. But first, I needed a feed of
my website that was in JSON, not XML.</p>

<p>So I hit up <a href="https://phpc.social/@kboyd">Kevin Boyd</a> and ask him how
could I do this in Sculpin. He very gracious created a Twig template
that would turn my list of blog posts into a JSON feed. Here it is
in all it's glory:</p>

<pre><code>
---
permalink: feed.json
use:
    - posts
---
{#
     Example data structure for delivering a Webmentions feed:

     From: https://blog.geheimesite.nl/en/index.json

     [
        {
            "author": {},
            "categories": ,
            "content": "yadda yadda yadda",
            "date": "2022-05-03T16:27:18+02:0",
            "site": "https://whateverthing.com/",
            "tags": null,
            "title": "Article One",
            "uri": "https://whateverthing.com/2022/11/11/article-one/"
        },
        {
            "author": {},
            "categories": ,
            "content": "yadda yadda yadda",
            "date": "2022-06-03T16:27:18+02:0",
            "site": "https://whateverthing.com/",
            "tags": null,
            "title": "Article Two",
            "uri": "https://whateverthing.com/2022/11/11/article-two/"
        },
     ]
#}
{% set outputArray = [] %}

{% for post in data.posts[:10] %}
    {%
        set postOutput = {
            'author': site.author,
            'categories': post.meta.categories,
            'content': post.blocks.content|raw,
            'date': post.date|date("c"),
            'site': site.global_url,
            'tags': post.meta.tags,
            'title': post.title,
            'uri': [ site.global_url, post.url]|join
        }
    %}
    {% set outputArray = outputArray|merge([postOutput]) %}
{% endfor %}

{{ outputArray|json_encode(constant('JSON_PRETTY_PRINT'))|raw }}

</code></pre>

<p>I dropped that into the root directory Sculpin uses for generating
my site, named it <code>feed.json.twig</code> and now I had a JSON-based feed
for the site.</p>

<p>Now, the GitHub action. This would go in <code>.github/workflows/send-webmention.yaml</code>
for my repo that I am using for the page.</p>

<pre><code>name: Send Webmentions

on: push

jobs:
  send:
    runs-on: ubuntu-latest
    steps:

      - name: Send Webmentions
        env:
          GITHUB_TOKEN: $
          URL: $
        run: |
          NEW=$(curl --silent $URL | jq -r first.uri)

          curl -X POST https://webmention.app/check?url="https://grumpy.learning.com$NEW"

          curl -H "Content-Type: application/x-www-form-urlencoded" --request POST \
          -d source="https://grumpy-learning.com$NEW" \
          -d target="https://brid.gy/publish/twitter" \
          "https://brid.gy/publish/webmention"

          curl -H "Content-Type: application/x-www-form-urlencoded" --request POST \
          -d source="https://grumpy-learning.com$NEW" \
          -d target="https://brid.gy/publish/mastodon" \
          "https://brid.gy/publish/webmention"
</code></pre>

<p>The <a href="https://gist.github.com/dianoetic/b45466a7c04fa47cf80905b182dbda3c">original instructions</a> recommended
putting the JSON feed details into a secret and then referencing it inside the action.
I am not sure it matters that much but stuck with it.</p>

<p>So, the next thing is that it grabs the feed using <a href="https://curl.se">cURL</a> and grabs what
it thinks is the latest post (the first one in the feed) and then proceeds to use
<a href="https://webmention.app">webmention.app</a> and Brid.gy to syndicate my content by sharing
the post title and linking to it).</p>

<p>So far it is working well and if you came across this post via my social media microblogging (I
sound so pretentious when I say it out loud) then it clearly worked.</p>

<p>I think my takeway from this is that gluing things together so your existing blog
can syndicate content to a variety of platforms. If you're looking to have more control over
the things you share online, I highly recommend looking into the IndieWeb. I hope this post helps!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Federating Yourself]]></title>
            <link href="https://grumpy-learning.com/blog/2022/11/12/federating-yourself/"/>
            <updated>2022-11-12T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/11/12/federating-yourself/</id>
            <content type="html"><![CDATA[<p>As I write this blog post, Twitter is convulsing as it's new
owner Elon Musk is trying to treat a huge cruise ship like
it's a jetski. Having cut a ton of staff and literally workshopping
ideas in public, it's not going well.</p>

<p>I have ignored blogging and some other interactions as Twitter made
it so easy to share those little thoughts and I also became reliant
on a curated feed to find stuff I was interested in. Along the way
I ran into the idea of the <a href="https://indieweb.org/">IndieWeb</a>.</p>

<p>I have made a non-trivial amount of money off selling my <a href="https://leanpub.com/u/chartjes">books</a>
and have dabbled in paid courses and workshops. So it made a lot of
sense to me to check out this <a href="https://indiewebify.me">guide to joining the IndieWeb</a>
and learn about <a href="https://microformats.org">microformats</a>, <a href="http://webmention.org/">Webmentions</a>
and start really leaning into POSSEing (Publish on my Own Site, Syndicate Elsewhere)
my stuff.</p>

<p>This is the first blog post that (if I have set up things correctly at my end) that
will be syndicated out to other platforms.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Asking Companies About Testing]]></title>
            <link href="https://grumpy-learning.com/blog/2022/01/14/asking-companies-about-testing/"/>
            <updated>2022-01-14T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/01/14/asking-companies-about-testing/</id>
            <content type="html"><![CDATA[<p>This post could also be subtitled "The Grumpy Programmer's Guide to Getting Rejected at Interviews".</p>

<p>Someone tagged me in a tweet...</p>

<blockquote>
  <p><em>Book idea for @grmpyprogrammer: an interviewing guide for job seekers wanting to get an idea of how dedicated companies are to testing. Questions to ask, ways to gauge the culture, etc.</em>
  <em>(Originally posted on Twitter at <a href="https://twitter.com/n00bJackleCity/status/1481632465403981824?s=20">https://twitter.com/n00bJackleCity/status/1481632465403981824?s=20</a>)</em></p>
</blockquote>

<p>...and it got me to thinking about where to start with
a request like this one. My personal opinion that there
really isn't a book in here but it did get me to start thinking
about what sort of questions you should be asking.</p>

<p>Again, keep in mind that all of this is just my opinion. One based
on many years of experience, but still an opinion.</p>

<h2 id="why-does-it-matter%3F">Why Does It Matter?</h2>

<p>In my experience, companies that make a commitment to doing automated
testing also tend to make a commitment towards "quality"
in their coding practices and "automation" in their software development tooling.
The reason those are in quotes is because they definitely can mean 
different things depending on the company.</p>

<p>Now, again, in my experience, you are likely to have more success
in solving problems and growing your own skills as a developer if you work
in an environment where they value those things.</p>

<p>After all, just because we can get paid a lot of money to dig in the pixel
mines doesn't mean we should be forced to eat a shit sandwich. We should at 
least have a choice of the additional toppings.</p>

<h2 id="what-questions-should-i-ask%3F">What Questions Should I Ask?</h2>

<p>Like a lot of things related to programming, I find it helpful to start at the
end result you want and work backwards to figure out what needs to be done. Therefore
I think the first two things to ask are:</p>

<blockquote>
  <blockquote>
    <p>What things always have to work when you push changes into production
    and how do you verify that it works as expected?</p>
  </blockquote>
</blockquote>

<p>This question cuts to the heart of the issue: what matters and how do we make
sure it stays that way.</p>

<p>What you are looking for is clear statements about what matters and clearer statements
about how they verify it. Again, not every company has invested the time and money
into having the ability for code changes to seamlessly flow from a development
environment into production, accompanied by effective automated tests and a clear understanding
of outcomes.</p>

<p>If they already have some kind of commitment to testing, asking follow-up questions
like this are also very informative:</p>

<blockquote>
  <blockquote>
    <p>What do you like about your current testing practices and what do you want to change?</p>
  </blockquote>
</blockquote>

<p>Pay as much attention to what they like as what they dislike. That will give you an idea
of what challenges lie ahead if you want to be the person making the changes.</p>

<p>Finally, if you want to find out about what their commitment to quality is, I feel like
a great question is:</p>

<blockquote>
  <blockquote>
    <p>Tell me about how code gets from the developer and up into production</p>
  </blockquote>
</blockquote>

<p>Look for things like:</p>

<ul>
<li>code reviews</li>
<li>coding standards</li>
<li>static code analysis</li>
<li>continuous integration systems</li>
<li>separate staging and production environments</li>
<li>automated deployments</li>
</ul>

<p>Not all of these things are going to guarantee great results (nothing
does and never believe anyone who says it) but, when taken together,
they show a commitment to making sure that:</p>

<ul>
<li>the intent of code is clear</li>
<li>others can understand the code</li>
<li>the code is taking advantage of appropriate language features</li>
<li>the team uses tooling that integrates with version control to automate error-prone manual checklists</li>
<li>application / end-to-end testing happens before it reaches production</li>
<li>repeatable processes ensure consistency</li>
</ul>

<h2 id="so-now-what%3F">So Now What?</h2>

<p>It's hard for me to give any more specific advice other than "don't be 
afraid to ask more questions based on the answers you are hearing." 
If we're being honest, most companies aren't doing all that stuff I listed
above. You can always start at the bottom ("we try and manually test all changes")
and work as hard as you are allowed to on getting to the point where you
have an automated test suite catching issues before your users do.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Solving Problems With Profiling]]></title>
            <link href="https://grumpy-learning.com/blog/2022/01/05/solving-problems-with-profiling/"/>
            <updated>2022-01-05T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/01/05/solving-problems-with-profiling/</id>
            <content type="html"><![CDATA[<p>I was presented with a problem that was occurring in the <a href="https://grumpy-learning.com/blog/2021/12/30/repeatable-dev-environments/">virtual machine</a>
I was using for client development work -- the PHP-based acceptance test suite was running
extremely slowly. Normally it takes 12-13 minutes to run outside of the 
virtual machine but it was taking...54 minutes!</p>

<p>Because I am almost never afraid to ask for help, I bugged <a href="https://twitter.com/ocramius">Marco Pivetta</a>
to give me a hand, since he is working on the same client project. I figured if anyone knew of where to START diagnosing what
the problem is, it would be Marco.</p>

<p>Marco's suggestion after watching a smaller test suite run both in his
local environment and in my VM was that we should run the test suite
with a debugger enabled so we can see what is going on terms of resources
being consumed. For PHP, this usually means using <a href="https://xdebug.org">Xdebug</a>.</p>

<p>What Xdebug allows you to do is:</p>

<ul>
<li><a href="https://xdebug.org/docs/step_debug">step debugging</a></li>
<li>see better <code>var_dump()</code> information</li>
<li>write every function call to disk for later summarizing and reporting</li>
<li>profile your code to look for performance bottlenecks</li>
<li>generate code coverage when using PHPUnit (not sure if it works with other testing frameworks)</li>
</ul>

<p>I've used the step debugging feature a lot on unfamiliar
code bases but the profiling feature was definitely what we needed.</p>

<p>To ask Xdebug to profile the code we're testing, you need to have the
Xdebug extension installed and then tell <a href="https://phpunit.de">PHPUnit</a> that you want
to use it. The command to do it from your shell looks something like
this:</p>

<p><code>XDEBUG_MODE=profile vendor/bin/phpunit --testsuite=unit</code></p>

<p>Because our test environment was configured to run these tests using a specific
Docker container, I had to access the container directly via <code>docker-compose exec php-fpm</code>
and then execute this command inside the container.</p>

<p>This ran the test suite and generated a large number of <a href="https://valgrind.org/docs/manual/cg-manual.html">cachegrind</a>
files. These files contain profiling data but you need a specialized
tool to read them and get information out of them that makes sense.
For Linux users you would likely want to use <a href="https://kcachegrind.github.io">KCachegrind</a>
but luckily for me you can read these files using <a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a>.</p>

<p>The first step was to figure out which of these cachegrind files to 
examine. Unfortunately this is more intuition than science: our test
suite uses <code>@runInSeparateProcess</code> annotations so all the small ones
represent single tests. These are likely not to return any meaningful 
information. "Just pick the biggest one and let's see what happens."</p>

<p>So, we both opened up cachegrind files of similar sizes and took a look
at the data. What exactly where we looking for? In terms of bottlenecks
we can place things in either "network" or "CPU" categories. Is the application
waiting a lot for external resources (say, a service in a different container)
or is it waiting for the CPU to finishing doing something before it 
can continue.</p>

<p>Sadly, I cannot share the cachegrind output here as I have NDA's surrounding
the client work but the approach was:</p>

<ul>
<li>sort the calls by how much time was being spent on executing them</li>
<li>figure out if it is network or CPU</li>
</ul>

<p>For network issues, we were looking for things like time spent connecting
to a MySQL database in another container. As we scrolled through the list
at my end together we started noticing a few things:</p>

<ul>
<li>network access wasn't the problem</li>
<li>we were spending an awful lot of time continually parsing a configuration file written using <a href="https://toml.io/en/">TOML</a> during bootstrap (ticket filed to fix this)</li>
<li>a lot of very simple PHP calls were taking significant amounts of CPU time</li>
</ul>

<p>The next step was to look at how much memory and CPU power I was giving to 
the virtual machine. I was giving it half my processing cores and half the
available memory. So that should not have been an issue.</p>

<p>Marco did some searching and found some forum posts of folks complaining about
how slow some VM's were in the latest version of <a href="https://www.vmware.com/products/fusion.html">VMWare Fusion</a>
but their situation didn't seem to be the same as ours.</p>

<p>"Hrm, Chris, open up that 'Advanced Options' section in the 'Processors &amp; Memory' configuration
section. Aha!"</p>

<p>In that section were two disabled options, both dealing with running containers
inside the virtual machine. Given that we are heavily relying on Docker it definitely
made sense to enable those.</p>

<p>So I shut down the virtual machine, enabled those two options, and started it up.
Much to my surprise, the acceptance test suite now ran in 10 minutes instead of
54 minutes! Huge improvement and is also faster than how long it takes outside
of the virtual machine.</p>

<p>Afterwards, Marco was explaining to me how much Docker relies on having direct memory
access to things so not forcing those connections to go through a different path
in the VM would yield a huge gain. Now I'm happier with the performance of the test
suite.</p>

<p>So, in summary:</p>

<ul>
<li>the test suite was much slower than expected</li>
<li>a decision was made to run the test suite with Xdebug profiling enabled</li>
<li>we made an educated guess as to which profile output file to analyze</li>
<li>the profiling output led us to believe that there was a CPU-related bottleneck</li>
<li>the virtual machine had adequate memory and processor resources allocated to it</li>
<li>the VM was not configured to run containerized applications optimally</li>
<li>the VM has stopped and options pertaining to running containers inside the VM were enabled</li>
<li>re-running the test suite saw a huge increase in performance and execution time</li>
</ul>

<p>Without the ability to profile the code to get a better idea of where there might 
be problems, it would've taken a lot longer to come to an effective solution.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Better Outcomes]]></title>
            <link href="https://grumpy-learning.com/blog/2022/01/02/better-outcomes/"/>
            <updated>2022-01-02T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2022/01/02/better-outcomes/</id>
            <content type="html"><![CDATA[<p>I’m not a New Year’s resolution type but here are some suggestions for my fellow devs of things I believe can lead to better outcomes:</p>

<p>Learn your IDE/editor better: I spent a lot of 2021 refining my <a href="https://neovim.org">Vim</a> setup and I plan on adding increased use of <a href="https://vimwiki.github.io/">VimWiki</a> for making notes and linking things together.</p>

<p>If your dynamic language of choice supports types, start using them and <a href="https://psalm.dev">static</a> <a href="https://phpstan.org">analysis</a> tools. It leads to much clearer intent and can catch problems at the edges.</p>

<p>Focus on automation. Stop doing things manually the computer can do for you. Take the time to semi-automate manual processes first. It frees your brain up to solve different problems.</p>

<p>Make continuous learning a foundation of everything you do. Even after 23 years of getting paid to program, I learn new things almost every day.</p>

<p>Remember that what people call “luck” is often you having the skills to take advantage of an opportunity.</p>

<p>(This was originally posted as a Twitter thread starting with <a href="https://twitter.com/grmpyprogrammer/status/1477326886766362626">https://twitter.com/grmpyprogrammer/status/1477326886766362626</a>)</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Repeatable Development Environments]]></title>
            <link href="https://grumpy-learning.com/blog/2021/12/30/repeatable-dev-environments/"/>
            <updated>2021-12-30T00:00:00+00:00</updated>
            <id>https://grumpy-learning.com/blog/2021/12/30/repeatable-dev-environments/</id>
            <content type="html"><![CDATA[<p>If you have used <a href="https://docker.com">Docker</a> on a Mac
laptop, you have likely ran into the "crossing file systems"
issue that can lead to really poor performance in your containers.
This becomes frustrating if you are recreating a development environment 
for applications that rely on a lot of services (micro or otherwise)
 to run. If you are a Windows or Linux user, this sort of thing is pretty much
a non-issue.</p>

<p>It seemed like I had two choices on how to potentially deal with this.
Choice number one was to switch to a different operating system (I have been looking
at <a href="https://frame.work">Framework</a> laptops) but I was (LOL) grumpy about
getting a new laptop when the 2020 13" MacBook pro I have as I write this is only slightly
more than a year old. Okay, I could sell it. But that seems like a bunch
of busy work.</p>

<p>The second choice was to see if I could create a development environment
that was faster and still allowed me to use Docker, which is 100% a requirement
for the client work I am currently doing.</p>

<p>In the past, other people online had hinted at the possibility of doing the development
work inside a virtual machine. Basically like connecting to another machine
via SSH and then doing my work in there. Good thing I am already a member of the 
Cult of Vim.</p>

<p>Okay, I think I could work with this. The next issue was HOW to do this all. I've played
around enough with <a href="https://www.vagrantup.com/">Vagrant</a>, <a href="https://vmware.com">VMWare</a> and
Virtual Private Servers to know that the steepest part of the curve with using
this solution is getting configured and in a state where it useful rather than
a time-sink or a toy.</p>

<p>I am always one to extol the virtues of "better lucky than good" and I happened to
stumble across a tweet from Mitchell Hashimoto (one of the creators of Vagrant)
where he talked about how he does all his development work inside a VM running
on a Mac laptop. I can't find the original tweet, but I made a note about it
and then he did another tweet about it:</p>

<blockquote>
  <p><em>My NixOS configurations for my dev VM setup are finally sanitized and open source. They work for both Intel and Apple Silicon. And I put together a video showing how I setup a new machine!</em>
  (originally posted at <a href="https://twitter.com/mitchellh/status/1452721115009191938">https://twitter.com/mitchellh/status/1452721115009191938</a>)</p>
</blockquote>

<p>In that tweet he also shared a link to a <a href="https://www.youtube.com/watch?v=ubDMLoWz76U">YouTube video</a> and
the <a href="https://github.com/mitchellh/nixos-config">GitHub repo</a> that he was publicly sharing
that you could use as a template.</p>

<p>Again, in a big coincidence, Mr. Hashimoto was also using <a href="https://nixos.org">NixOS</a> as his
VM's operating system. NixOS is a Linux distribution based on <a href="https://nixos.org/manual/nix/stable/introduction.html">Nix package manager</a>.
Which doesn't mean much if you're not a fan of their approach.</p>

<p>The reason to like Nix is that it bills itself as a <em>purely functional package manager</em>.
If you've ever come across the "functional style" of programming then you might know
how powerful it is to have code that has no "side effects". This means that your
code is not doing things like writing to the file system, or updating records in a database.
In a functional world (unless the code is supposed return something random) it is easy
to test code because the same input should always generate the same output.</p>

<p>If you apply this to package management, it means your are choosing and installing dependencies
in such a way that you can isolate them from each other. It can be difficult to have, for example,
two different versions of PHP installed for your use unless you are relying on third party tools
to keep track of what version should be active.</p>

<p>Nix handles this by forcing you to declare any dependencies explicitly. No more
worrying about globally-installed libraries causing incompatibility problems. 
Want to see if your PHP project runs on 7.4, 8.0, and 8.1? You can do that easily
with NixOS and it's tooling.</p>

<p>I guess you can tell I am a fan of NixOS and look forward to using it a lot more.</p>

<p>The idea from a high level is this: given a NixOS VM running in VMWare (I am using
VMWare Fusion) it should take less than 10 minutes to create a development
environment configured with my preferred tools installed from scratch.</p>

<p>The repo he provides is definitely not ready to go as-is. You will need to modify
a lot of the things in there -- I know I did. It took about a week of poking at it,
creating and destroying lots of VM's, and learning how NixOS wants to do things to
get it to the point where I could get it up and running and actually use it.</p>

<p>I ended up removing a bunch of tools that are related to Mitchell's work on Docker
and added a few things I knew I was going to need for my work with this client. It
also took me a while to figure out how to generate a hash for the password for the 
user account the build-and-configure process can create for you. But in the
end I had a VM up and running (that I could also SSH into if I wanted to)</p>

<p>By default, the VM uses a graphical interface with a <a href="https://i3wm.org/">tiling window manager</a>
and you type Command-N on your Mac and it opens up a terminal session in 
<a href="https://sw.kovidgoyal.net/kitty/">Kitty</a> and you are ready to go!.</p>

<p>I also had modified the configuration to install Docker and the related
command-line tools. Once I cloned the client repo all I had to do was
<code>make build</code> to create the Docker containers the development environment
needed and <code>make unit</code> to run the unit test suite in less than half the time.</p>

<p>So what is the point of doing all this work? Let's go back to my original
problem. Running a test suite that used a development environment consisting
of multiple Docker containers was incredibly slow. Running on my Mac (and giving
Docker half the cores and half the available memory) it takes about 80 seconds.
Running inside a VM that has access to the same resources takes about 35 seconds.</p>

<p>If you've never done a development work flow of "make a change, run a process to 
verify the change works as expected" for a large chunk of your work day then perhaps
you don't think this is a big deal. Every loop also has come context switching
as you try and figure out what happened. If you do this 100 times in a day, you
probably want this loop to run as quickly as possible.</p>

<p>I don't know if there is a phrase or concept or "law" about this sort of perception-versus-reality
issue, but I find myself wanting to get things done FASTER when the process by
which results are determined gets SLOWER. When my test suite runs in 30 seconds,
I feel like I have lots of time to solve the problem. When it takes a minute-and-a-half
I get...anxious? Maybe that's the wrong emotion. I know something takes too long 
when I start muttering to myself "this is taking too <insert preferred swear word> long.".</p>

<p>With the "happens faster than before" issue solved, I find the next benefit to be 
as I learn how to use Nix to build repeatable environments, a major mistake can be 
solved by deleting the VM and trying again. Maybe 20 minutes tops to get back to 
where I was. When I mess up my development environment
on my MacBook (OS update or maybe <a href="https://brew.sh/">Homebrew</a> updates an underlying
dependency) it can be a whole afternoon spent trying to "fix whatever I broke."</p>

<p>It's not clear there will ever be any kind of solution for the "crossing file systems"
issue that leads to Docker performing so poorly. My fellow programmers who are
running the newer MacBooks that use Apple's new chips tell me performance is 
quite good. Spending another CAD$3k so Docker runs faster seems like a waste of 
money to me, but that is just a personal opinion.</p>

<p>I used to be someone who lived on the bleeding edge when it came to their software.
As I got older and grumpier I started to value stability and repeatability in my 
software more. A development environment that can be built using <a href="https://www.gnu.org/software/make/">Make</a>
and a VM is one I can rely on to start me off at a known point, exhibiting
behaviour I am expecting. Almost like the benefits of a test suite!</p>

<p>Doing this NixOS-in-a-VM stuff relies on you having some experience with Linux 
environments. I did run Linux as my desktop environment for several years 
before I started buying Apple hardware (which I've done since 2002) and 
MacOS's "<a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a> with a pretty window manager" approach also let me use those
command-line skills.</p>

<p>I highly recommend watching Mitchell's YouTube video as he explains how the
whole process works. I found it useful because he explains the philosophy of 
his approach. Understanding WHY someone does things can often lead you to 
quicker insights as to what needs to change to fit your needs.</p>

<p>If you do get it all set up, let me know your experiences. With some effort
I can probably create a more generic version of my set up and create a GitHub
repo with all the files in it.</p>
]]></content>
        </entry>
    </feed>